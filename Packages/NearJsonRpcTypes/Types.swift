// Generated by NEAR Protocol Swift Type Generator
// Do not edit manually - Generated from OpenAPI specification
// Generated on: 2025-10-14 06:18:59 +0000

import Foundation
/// This action allows to execute the inner actions behalf of the defined sender.
public struct DelegateAction: Codable, Sendable {
    /// List of actions to be executed.
    /// 
    /// With the meta transactions MVP defined in NEP-366, nested
    /// DelegateActions are not allowed. A separate type is used to enforce it.
    public let actions: [NonDelegateAction]
    /// The maximal height of the block in the blockchain below which the given DelegateAction is valid.
    public let max_block_height: UInt64
    /// Nonce to ensure that the same delegate action is not sent twice by a
    /// relayer and should match for given account's `public_key`.
    /// After this action is processed it will increment.
    public let nonce: UInt64
    /// Public key used to sign this delegated action.
    public let public_key: PublicKey
    /// Receiver of the delegated actions.
    public let receiver_id: AccountId
    /// Signer of the delegated actions
    public let sender_id: AccountId

    public init(actions: [NonDelegateAction], max_block_height: UInt64, nonce: UInt64, public_key: PublicKey, receiver_id: AccountId, sender_id: AccountId) {
        self.actions = actions
        self.max_block_height = max_block_height
        self.nonce = nonce
        self.public_key = public_key
        self.receiver_id = receiver_id
        self.sender_id = sender_id
    }
}

/// Grants limited permission to make transactions with FunctionCallActions
/// The permission can limit the allowed balance to be spent on the prepaid gas.
/// It also restrict the account ID of the receiver for this function call.
/// It also can restrict the method name for the allowed function calls.
public struct FunctionCallPermission: Codable, Sendable {
    /// Allowance is a balance limit to use by this access key to pay for function call gas and
    /// transaction fees. When this access key is used, both account balance and the allowance is
    /// decreased by the same value.
    /// `None` means unlimited allowance.
    /// NOTE: To change or increase the allowance, the old access key needs to be deleted and a new
    /// access key should be created.
    public let allowance: String?
    /// A list of method names that can be used. The access key only allows transactions with the
    /// function call of one of the given method names.
    /// Empty list means any method name can be used.
    public let method_names: [String]
    /// The access key only allows transactions with the given receiver's account id.
    public let receiver_id: String

    public init(allowance: String?, method_names: [String], receiver_id: String) {
        self.allowance = allowance
        self.method_names = method_names
        self.receiver_id = receiver_id
    }
}

/// Serializable version of `near-vm-runner::FunctionCallError`.
/// 
/// Must never reorder/remove elements, can only add new variants at the end (but do that very
/// carefully). It describes stable serialization format, and only used by serialization logic.
public enum FunctionCallError: Codable, Sendable {
    case wasmunknownerror
    case _evmerror
    case case0(CompilationError: CompilationError)
    case case01(LinkError: String)
    case case02(MethodResolveError: MethodResolveError)
    case case03(WasmTrap: WasmTrap)
    case case04(HostError: HostError)
    case case05(ExecutionError: String)
}

public struct RpcNetworkInfoRequest: Codable, Sendable {
    public init() {}
}

public enum ExecutionStatusView: Codable, Sendable {
    case unknown
    case case0(Failure: TxExecutionError)
    case case01(SuccessValue: String)
    case case02(SuccessReceiptId: CryptoHash)
}

/// NEAR Account Identifier.
/// 
/// This is a unique, syntactically valid, human-readable account identifier on the NEAR network.
/// 
/// [See the crate-level docs for information about validation.](index.html#account-id-rules)
/// 
/// Also see [Error kind precedence](AccountId#error-kind-precedence).
/// 
/// ## Examples
/// 
/// ```
/// use near_account_id::AccountId;
/// 
/// let alice: AccountId = "alice.near".parse().unwrap();
/// 
/// assert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f)
/// ```
public typealias AccountId = String

public typealias Direction = String

public struct Tier1ProxyView: Codable, Sendable {
    public let addr: String
    public let peer_id: PublicKey

    public init(addr: String, peer_id: PublicKey) {
        self.addr = addr
        self.peer_id = peer_id
    }
}

public struct RpcKnownProducer: Codable, Sendable {
    public let account_id: AccountId
    public let addr: String?
    public let peer_id: PeerId

    public init(account_id: AccountId, addr: String?, peer_id: PeerId) {
        self.account_id = account_id
        self.addr = addr
        self.peer_id = peer_id
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_changes: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcStateChangesInBlockByTypeRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcStateChangesInBlockByTypeRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// Deploy global contract action
public struct DeployGlobalContractAction: Codable, Sendable {
    /// WebAssembly binary
    public let code: String
    public let deploy_mode: GlobalContractDeployMode

    public init(code: String, deploy_mode: GlobalContractDeployMode) {
        self.code = code
        self.deploy_mode = deploy_mode
    }
}

public enum JsonRpcResponse_for_CryptoHash_and_RpcError: Codable, Sendable {
    case case0(result: CryptoHash)
    case case01(error: RpcError)
}

/// A result returned by contract method
public struct CallResult: Codable, Sendable {
    public let logs: [String]
    public let result: [String]

    public init(logs: [String], result: [String]) {
        self.logs = logs
        self.result = result
    }
}

public enum InvalidAccessKeyError: Codable, Sendable {
    case case0(AccessKeyNotFound: String)
    case case01(ReceiverMismatch: String)
    case case02(MethodNameMismatch: String)
    case requiresfullaccess
    case case03(NotEnoughAllowance: String)
    case depositwithfunctioncall
}

public enum JsonRpcResponse_for_Nullable_RpcHealthResponse_and_RpcError: Codable, Sendable {
    case case0(result: String)
    case case01(error: RpcError)
}

public typealias RpcSplitStorageInfoRequest = String

public struct JsonRpcRequest_for_network_info: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcNetworkInfoRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcNetworkInfoRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct RpcSendTransactionRequest: Codable, Sendable {
    public let signed_tx_base64: SignedTransaction
    public let wait_until: TxExecutionStatus?

    public init(signed_tx_base64: SignedTransaction, wait_until: TxExecutionStatus?) {
        self.signed_tx_base64 = signed_tx_base64
        self.wait_until = wait_until
    }
}

/// `BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.
/// When a shard wants to send a lot of receipts to another shard, it needs to create a request and wait
/// for a bandwidth grant from the bandwidth scheduler.
public struct BandwidthRequest: Codable, Sendable {
    /// Bitmap which describes what values of bandwidth are requested.
    public let requested_values_bitmap: BandwidthRequestBitmap
    /// Requesting bandwidth to this shard.
    public let to_shard: String

    public init(requested_values_bitmap: BandwidthRequestBitmap, to_shard: String) {
        self.requested_values_bitmap = requested_values_bitmap
        self.to_shard = to_shard
    }
}

public struct JsonRpcRequest_for_next_light_client_block: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcLightClientNextBlockRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcLightClientNextBlockRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct SignedDelegateAction: Codable, Sendable {
    public let delegate_action: DelegateAction
    public let signature: Signature

    public init(delegate_action: DelegateAction, signature: Signature) {
        self.delegate_action = delegate_action
        self.signature = signature
    }
}

public enum ValidatorStakeView: Codable, Sendable {
    case case0(validator_stake_struct_version: String)
}

public enum HostError: Codable, Sendable {
    case badutf16
    case badutf8
    case gasexceeded
    case gaslimitexceeded
    case balanceexceeded
    case emptymethodname
    case case0(GuestPanic: String)
    case integeroverflow
    case case01(InvalidPromiseIndex: String)
    case cannotappendactiontojointpromise
    case cannotreturnjointpromise
    case case02(InvalidPromiseResultIndex: String)
    case case03(InvalidRegisterId: String)
    case case04(IteratorWasInvalidated: String)
    case memoryaccessviolation
    case case05(InvalidReceiptIndex: String)
    case case06(InvalidIteratorIndex: String)
    case invalidaccountid
    case invalidmethodname
    case invalidpublickey
    case case07(ProhibitedInView: String)
    case case08(NumberOfLogsExceeded: String)
    case case09(KeyLengthExceeded: String)
    case case010(ValueLengthExceeded: String)
    case case011(TotalLogLengthExceeded: String)
    case case012(NumberPromisesExceeded: String)
    case case013(NumberInputDataDependenciesExceeded: String)
    case case014(ReturnedValueLengthExceeded: String)
    case case015(ContractSizeExceeded: String)
    case case016(Deprecated: String)
    case case017(ECRecoverError: String)
    case case018(AltBn128InvalidInput: String)
    case case019(Ed25519VerifyInvalidInput: String)
}

public enum JsonRpcResponse_for_RpcBlockResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcBlockResponse)
    case case01(error: RpcError)
}

public struct MissingTrieValue: Codable, Sendable {
    public let context: MissingTrieValueContext
    public let hash: CryptoHash

    public init(context: MissingTrieValueContext, hash: CryptoHash) {
        self.context = context
        self.hash = hash
    }
}

public struct ValidatorStakeViewV1: Codable, Sendable {
    public let account_id: AccountId
    public let public_key: PublicKey
    public let stake: NearToken

    public init(account_id: AccountId, public_key: PublicKey, stake: NearToken) {
        self.account_id = account_id
        self.public_key = public_key
        self.stake = stake
    }
}

/// It is a [serializable view] of [`StateChangeKind`].
/// 
/// [serializable view]: ./index.html
/// [`StateChangeKind`]: ../types/struct.StateChangeKind.html
public enum StateChangeKindView: Codable, Sendable {
    case case0(account_id: AccountId, type: String)
    case case01(account_id: AccountId, type: String)
    case case02(account_id: AccountId, type: String)
    case case03(account_id: AccountId, type: String)
}

/// Configures how to fetch state parts during state sync.
public enum SyncConfig: Codable, Sendable {
    case peers
    case case0(ExternalStorage: ExternalStorageConfig)
}

public enum RpcRequestValidationErrorKind: Codable, Sendable {
    case case0(info: String, name: String)
    case case01(info: String, name: String)
}

public struct RpcLightClientNextBlockRequest: Codable, Sendable {
    public let last_block_hash: CryptoHash

    public init(last_block_hash: CryptoHash) {
        self.last_block_hash = last_block_hash
    }
}

/// Execution outcome of the transaction and all the subsequent receipts.
/// Could be not finalized yet
public struct FinalExecutionOutcomeView: Codable, Sendable {
    /// The execution outcome of receipts.
    public let receipts_outcome: [ExecutionOutcomeWithIdView]
    /// Execution status defined by chain.rs:get_final_transaction_result
    /// FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet
    /// FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution
    /// FinalExecutionStatus::Failure - the result of the first leaf receipt_id
    /// FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id
    public let status: FinalExecutionStatus
    /// Signed Transaction
    public let transaction: SignedTransactionView
    /// The execution outcome of the signed transaction.
    public let transaction_outcome: ExecutionOutcomeWithIdView

    public init(receipts_outcome: [ExecutionOutcomeWithIdView], status: FinalExecutionStatus, transaction: SignedTransactionView, transaction_outcome: ExecutionOutcomeWithIdView) {
        self.receipts_outcome = receipts_outcome
        self.status = status
        self.transaction = transaction
        self.transaction_outcome = transaction_outcome
    }
}

public enum GlobalContractIdentifierView: Codable, Sendable {
    case case0
    case case1
}

/// An error happened during TX execution
public enum InvalidTxError: Codable, Sendable {
    case case0(InvalidAccessKeyError: InvalidAccessKeyError)
    case case01(InvalidSignerId: String)
    case case02(SignerDoesNotExist: String)
    case case03(InvalidNonce: String)
    case case04(NonceTooLarge: String)
    case case05(InvalidReceiverId: String)
    case invalidsignature
    case case06(NotEnoughBalance: String)
    case case07(LackBalanceForState: String)
    case costoverflow
    case invalidchain
    case expired
    case case08(ActionsValidation: ActionsValidationError)
    case case09(TransactionSizeExceeded: String)
    case invalidtransactionversion
    case case010(StorageError: StorageError)
    case case011(ShardCongested: String)
    case case012(ShardStuck: String)
}

public struct JsonRpcRequest_for_EXPERIMENTAL_maintenance_windows: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcMaintenanceWindowsRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcMaintenanceWindowsRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct SyncConcurrency: Codable, Sendable {
    /// Maximum number of "apply parts" tasks that can be performed in parallel.
    /// This is a very disk-heavy task and therefore we set this to a low limit,
    /// or else the rocksdb contention makes the whole server freeze up.
    public let apply: String
    /// Maximum number of "apply parts" tasks that can be performed in parallel
    /// during catchup. We set this to a very low value to avoid overloading the
    /// node while it is still performing normal tasks.
    public let apply_during_catchup: String
    /// Maximum number of outstanding requests for decentralized state sync.
    public let peer_downloads: String
    /// The maximum parallelism to use per shard. This is mostly for fairness, because
    /// the actual rate limiting is done by the TaskTrackers, but this is useful for
    /// balancing the shards a little.
    public let per_shard: String

    public init(apply: String, apply_during_catchup: String, peer_downloads: String, per_shard: String) {
        self.apply = apply
        self.apply_during_catchup = apply_during_catchup
        self.peer_downloads = peer_downloads
        self.per_shard = per_shard
    }
}

/// Height and hash of a block
public struct BlockStatusView: Codable, Sendable {
    public let hash: CryptoHash
    public let height: UInt64

    public init(hash: CryptoHash, height: UInt64) {
        self.hash = hash
        self.height = height
    }
}

public struct ValidatorInfo: Codable, Sendable {
    public let account_id: AccountId

    public init(account_id: AccountId) {
        self.account_id = account_id
    }
}

public struct JsonRpcRequest_for_validators: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcValidatorRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcValidatorRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct RpcLightClientBlockProofResponse: Codable, Sendable {
    public let block_header_lite: LightClientBlockLiteView
    public let block_proof: [MerklePathItem]

    public init(block_header_lite: LightClientBlockLiteView, block_proof: [MerklePathItem]) {
        self.block_header_lite = block_header_lite
        self.block_proof = block_proof
    }
}

public enum CompilationError: Codable, Sendable {
    case case0(CodeDoesNotExist: String)
    case case01(PrepareError: PrepareError)
    case case02(WasmerCompileError: String)
}

/// This enum represents if a storage_get call will be performed through flat storage or trie
public typealias StorageGetMode = String

/// Describes the expected behavior of the node regarding shard tracking.
/// If the node is an active validator, it will also track the shards it is responsible for as a validator.
public enum TrackedShardsConfig: Codable, Sendable {
    case noshards
    case case0(Shards: [ShardUId])
    case allshards
    case case01(ShadowValidator: AccountId)
    case case02(Schedule: [[ShardId]])
    case case03(Accounts: [AccountId])
}

public struct RpcGasPriceRequest: Codable, Sendable {
    public let block_id: String?
}

public enum RpcBlockRequest: Codable, Sendable {
    case case0(block_id: BlockId)
    case case01(finality: Finality)
    case case02(sync_checkpoint: SyncCheckpoint)
}

public struct VMConfigView: Codable, Sendable {
    /// See [VMConfig::deterministic_account_ids](crate::vm::Config::deterministic_account_ids).
    public let deterministic_account_ids: Bool
    /// See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections).
    public let discard_custom_sections: Bool
    /// See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts).
    public let eth_implicit_accounts: Bool
    /// Costs for runtime externals
    public let ext_costs: ExtCostsConfigView
    /// See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost).
    public let fix_contract_loading_cost: Bool
    /// See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns).
    public let global_contract_host_fns: Bool
    /// Gas cost of a growing memory by single page.
    public let grow_mem_cost: UInt32
    /// See [VMConfig::implicit_account_creation](crate::vm::Config::implicit_account_creation).
    public let implicit_account_creation: Bool
    /// Describes limits for VM and Runtime.
    /// 
    /// TODO: Consider changing this to `VMLimitConfigView` to avoid dependency
    /// on runtime.
    public let limit_config: LimitConfig
    /// Base gas cost of a linear operation
    public let linear_op_base_cost: UInt64
    /// Unit gas cost of a linear operation
    public let linear_op_unit_cost: UInt64
    /// See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory).
    public let reftypes_bulk_memory: Bool
    /// Gas cost of a regular operation.
    public let regular_op_cost: UInt32
    /// See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int).
    public let saturating_float_to_int: Bool
    /// See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode).
    public let storage_get_mode: StorageGetMode
    /// See [VMConfig::vm_kind](crate::vm::Config::vm_kind).
    public let vm_kind: VMKind

    public init(deterministic_account_ids: Bool, discard_custom_sections: Bool, eth_implicit_accounts: Bool, ext_costs: ExtCostsConfigView, fix_contract_loading_cost: Bool, global_contract_host_fns: Bool, grow_mem_cost: UInt32, implicit_account_creation: Bool, limit_config: LimitConfig, linear_op_base_cost: UInt64, linear_op_unit_cost: UInt64, reftypes_bulk_memory: Bool, regular_op_cost: UInt32, saturating_float_to_int: Bool, storage_get_mode: StorageGetMode, vm_kind: VMKind) {
        self.deterministic_account_ids = deterministic_account_ids
        self.discard_custom_sections = discard_custom_sections
        self.eth_implicit_accounts = eth_implicit_accounts
        self.ext_costs = ext_costs
        self.fix_contract_loading_cost = fix_contract_loading_cost
        self.global_contract_host_fns = global_contract_host_fns
        self.grow_mem_cost = grow_mem_cost
        self.implicit_account_creation = implicit_account_creation
        self.limit_config = limit_config
        self.linear_op_base_cost = linear_op_base_cost
        self.linear_op_unit_cost = linear_op_unit_cost
        self.reftypes_bulk_memory = reftypes_bulk_memory
        self.regular_op_cost = regular_op_cost
        self.saturating_float_to_int = saturating_float_to_int
        self.storage_get_mode = storage_get_mode
        self.vm_kind = vm_kind
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_congestion_level: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcCongestionLevelRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcCongestionLevelRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct DeterministicAccountStateInitV1: Codable, Sendable {
    public let code: GlobalContractIdentifier
    public let data: String

    public init(code: GlobalContractIdentifier, data: String) {
        self.code = code
        self.data = data
    }
}

public struct SignedTransactionView: Codable, Sendable {
    public let actions: [ActionView]
    public let hash: CryptoHash
    public let nonce: UInt64
    public let priority_fee: UInt64?
    public let public_key: PublicKey
    public let receiver_id: AccountId
    public let signature: Signature
    public let signer_id: AccountId

    public init(actions: [ActionView], hash: CryptoHash, nonce: UInt64, priority_fee: UInt64?, public_key: PublicKey, receiver_id: AccountId, signature: Signature, signer_id: AccountId) {
        self.actions = actions
        self.hash = hash
        self.nonce = nonce
        self.priority_fee = priority_fee
        self.public_key = public_key
        self.receiver_id = receiver_id
        self.signature = signature
        self.signer_id = signer_id
    }
}

/// Resulting state values for a view state query request
public struct ViewStateResult: Codable, Sendable {
    public let proof: [String]?
    public let values: [StateItem]

    public init(proof: [String]?, values: [StateItem]) {
        self.proof = proof
        self.values = values
    }
}

/// The fees settings for a data receipt creation
public struct DataReceiptCreationConfigView: Codable, Sendable {
    /// Base cost of creating a data receipt.
    /// Both `send` and `exec` costs are burned when a new receipt has input dependencies. The gas
    /// is charged for each input dependency. The dependencies are specified when a receipt is
    /// created using `promise_then` and `promise_batch_then`.
    /// NOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.
    /// Even if the last action is not a function call (in case of success it will return empty
    /// value).
    public let base_cost: Fee
    /// Additional cost per byte sent.
    /// Both `send` and `exec` costs are burned when a function call finishes execution and returns
    /// `N` bytes of data to every output dependency. For each output dependency the cost is
    /// `(send(sir) + exec()) * N`.
    public let cost_per_byte: Fee

    public init(base_cost: Fee, cost_per_byte: Fee) {
        self.base_cost = base_cost
        self.cost_per_byte = cost_per_byte
    }
}

public enum JsonRpcResponse_for_RpcGasPriceResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcGasPriceResponse)
    case case01(error: RpcError)
}

public typealias AccountIdValidityRulesVersion = String

public struct RpcValidatorsOrderedRequest: Codable, Sendable {
    public let block_id: String?
}

public enum JsonRpcResponse_for_RpcValidatorResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcValidatorResponse)
    case case01(error: RpcError)
}

/// Describes cost of storage per block
public struct StorageUsageConfigView: Codable, Sendable {
    /// Number of bytes for an account record, including rounding up for account id.
    public let num_bytes_account: UInt64
    /// Additional number of bytes for a k/v record
    public let num_extra_bytes_record: UInt64

    public init(num_bytes_account: UInt64, num_extra_bytes_record: UInt64) {
        self.num_bytes_account = num_bytes_account
        self.num_extra_bytes_record = num_extra_bytes_record
    }
}

public enum JsonRpcResponse_for_GenesisConfig_and_RpcError: Codable, Sendable {
    case case0(result: GenesisConfig)
    case case01(error: RpcError)
}

public enum ActionErrorKind: Codable, Sendable {
    case case0(AccountAlreadyExists: String)
    case case01(AccountDoesNotExist: String)
    case case02(CreateAccountOnlyByRegistrar: String)
    case case03(CreateAccountNotAllowed: String)
    case case04(ActorNoPermission: String)
    case case05(DeleteKeyDoesNotExist: String)
    case case06(AddKeyAlreadyExists: String)
    case case07(DeleteAccountStaking: String)
    case case08(LackBalanceForState: String)
    case case09(TriesToUnstake: String)
    case case010(TriesToStake: String)
    case case011(InsufficientStake: String)
    case case012(FunctionCallError: FunctionCallError)
    case case013(NewReceiptValidationError: ReceiptValidationError)
    case case014(OnlyImplicitAccountCreationAllowed: String)
    case case015(DeleteAccountWithLargeState: String)
    case delegateactioninvalidsignature
    case case016(DelegateActionSenderDoesNotMatchTxReceiver: String)
    case delegateactionexpired
    case case017(DelegateActionAccessKeyError: InvalidAccessKeyError)
    case case018(DelegateActionInvalidNonce: String)
    case case019(DelegateActionNonceTooLarge: String)
    case case020(GlobalContractDoesNotExist: String)
}

public struct RpcNetworkInfoResponse: Codable, Sendable {
    public let active_peers: [RpcPeerInfo]
    /// Accounts of known block and chunk producers from routing table.
    public let known_producers: [RpcKnownProducer]
    public let num_active_peers: String
    public let peer_max_count: UInt32
    public let received_bytes_per_sec: UInt64
    public let sent_bytes_per_sec: UInt64

    public init(active_peers: [RpcPeerInfo], known_producers: [RpcKnownProducer], num_active_peers: String, peer_max_count: UInt32, received_bytes_per_sec: UInt64, sent_bytes_per_sec: UInt64) {
        self.active_peers = active_peers
        self.known_producers = known_producers
        self.num_active_peers = num_active_peers
        self.peer_max_count = peer_max_count
        self.received_bytes_per_sec = received_bytes_per_sec
        self.sent_bytes_per_sec = sent_bytes_per_sec
    }
}

/// Deploy contract action
public struct DeployContractAction: Codable, Sendable {
    /// WebAssembly binary
    public let code: String

    public init(code: String) {
        self.code = code
    }
}

/// Information about this epoch validators and next epoch validators
public struct RpcValidatorResponse: Codable, Sendable {
    /// Fishermen for the current epoch
    public let current_fishermen: [ValidatorStakeView]
    /// Proposals in the current epoch
    public let current_proposals: [ValidatorStakeView]
    /// Validators for the current epoch
    public let current_validators: [CurrentEpochValidatorInfo]
    /// Epoch height
    public let epoch_height: UInt64
    /// Epoch start block height
    public let epoch_start_height: UInt64
    /// Fishermen for the next epoch
    public let next_fishermen: [ValidatorStakeView]
    /// Validators for the next epoch
    public let next_validators: [NextEpochValidatorInfo]
    /// Kickout in the previous epoch
    public let prev_epoch_kickout: [ValidatorKickoutView]

    public init(current_fishermen: [ValidatorStakeView], current_proposals: [ValidatorStakeView], current_validators: [CurrentEpochValidatorInfo], epoch_height: UInt64, epoch_start_height: UInt64, next_fishermen: [ValidatorStakeView], next_validators: [NextEpochValidatorInfo], prev_epoch_kickout: [ValidatorKickoutView]) {
        self.current_fishermen = current_fishermen
        self.current_proposals = current_proposals
        self.current_validators = current_validators
        self.epoch_height = epoch_height
        self.epoch_start_height = epoch_start_height
        self.next_fishermen = next_fishermen
        self.next_validators = next_validators
        self.prev_epoch_kickout = prev_epoch_kickout
    }
}

/// Different types of finality.
public typealias Finality = String

public struct JsonRpcRequest_for_light_client_proof: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcLightClientExecutionProofRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcLightClientExecutionProofRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct JsonRpcRequest_for_status: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcStatusRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcStatusRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).
public struct CostGasUsed: Codable, Sendable {
    public let cost: String
    /// Either ACTION_COST or WASM_HOST_COST.
    public let cost_category: String
    public let gas_used: String

    public init(cost: String, cost_category: String, gas_used: String) {
        self.cost = cost
        self.cost_category = cost_category
        self.gas_used = gas_used
    }
}

/// Status of the [catchup](https://near.github.io/nearcore/architecture/how/sync.html#catchup) process
public struct CatchupStatusView: Codable, Sendable {
    public let blocks_to_catchup: [BlockStatusView]
    public let shard_sync_status: String
    public let sync_block_hash: CryptoHash
    public let sync_block_height: UInt64

    public init(blocks_to_catchup: [BlockStatusView], shard_sync_status: String, sync_block_hash: CryptoHash, sync_block_height: UInt64) {
        self.blocks_to_catchup = blocks_to_catchup
        self.shard_sync_status = shard_sync_status
        self.sync_block_hash = sync_block_hash
        self.sync_block_height = sync_block_height
    }
}

public struct DeleteAccountAction: Codable, Sendable {
    public let beneficiary_id: AccountId

    public init(beneficiary_id: AccountId) {
        self.beneficiary_id = beneficiary_id
    }
}

/// `ShardUId` is a unique representation for shards from different shard layouts.
/// 
/// Comparing to `ShardId`, which is just an ordinal number ranging from 0 to NUM_SHARDS-1,
/// `ShardUId` provides a way to unique identify shards when shard layouts may change across epochs.
/// This is important because we store states indexed by shards in our database, so we need a
/// way to unique identify shard even when shards change across epochs.
/// Another difference between `ShardUId` and `ShardId` is that `ShardUId` should only exist in
/// a node's internal state while `ShardId` can be exposed to outside APIs and used in protocol
/// level information (for example, `ShardChunkHeader` contains `ShardId` instead of `ShardUId`)
public struct ShardUId: Codable, Sendable {
    public let shard_id: UInt32
    public let version: UInt32

    public init(shard_id: UInt32, version: UInt32) {
        self.shard_id = shard_id
        self.version = version
    }
}

/// An action that adds key with public key associated
public struct AddKeyAction: Codable, Sendable {
    /// An access key with the permission
    public let access_key: AccessKey
    /// A public key which will be associated with an access_key
    public let public_key: PublicKey

    public init(access_key: AccessKey, public_key: PublicKey) {
        self.access_key = access_key
        self.public_key = public_key
    }
}

public struct RpcLightClientExecutionProofResponse: Codable, Sendable {
    public let block_header_lite: LightClientBlockLiteView
    public let block_proof: [MerklePathItem]
    public let outcome_proof: ExecutionOutcomeWithIdView
    public let outcome_root_proof: [MerklePathItem]

    public init(block_header_lite: LightClientBlockLiteView, block_proof: [MerklePathItem], outcome_proof: ExecutionOutcomeWithIdView, outcome_root_proof: [MerklePathItem]) {
        self.block_header_lite = block_header_lite
        self.block_proof = block_proof
        self.outcome_proof = outcome_proof
        self.outcome_root_proof = outcome_root_proof
    }
}

public struct ExecutionOutcomeWithIdView: Codable, Sendable {
    public let block_hash: CryptoHash
    public let id: CryptoHash
    public let outcome: ExecutionOutcomeView
    public let proof: [MerklePathItem]

    public init(block_hash: CryptoHash, id: CryptoHash, outcome: ExecutionOutcomeView, proof: [MerklePathItem]) {
        self.block_hash = block_hash
        self.id = id
        self.outcome = outcome
        self.proof = proof
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_tx_status: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcTransactionStatusRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcTransactionStatusRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct JsonRpcRequest_for_query: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcQueryRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcQueryRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// Account ID with its public key.
public struct AccountWithPublicKey: Codable, Sendable {
    public let account_id: AccountId
    public let public_key: PublicKey

    public init(account_id: AccountId, public_key: PublicKey) {
        self.account_id = account_id
        self.public_key = public_key
    }
}

public typealias NearGas = UInt64

public struct JsonRpcRequest_for_client_config: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcClientConfigRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcClientConfigRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// Bitmap which describes which values from the predefined list are being requested.
/// The nth bit is set to 1 when the nth value from the list is being requested.
public struct BandwidthRequestBitmap: Codable, Sendable {
    public let data: [String]

    public init(data: [String]) {
        self.data = data
    }
}

/// This type is used to mark values returned from store (arrays of bytes).
/// 
/// NOTE: Currently, this type is only used in the view_client and RPC to be able to transparently
/// pretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).
public typealias StoreValue = String

/// A list of shard's bandwidth requests.
/// Describes how much the shard would like to send to other shards.
public enum BandwidthRequests: Codable, Sendable {
    case case0(V1: BandwidthRequestsV1)
}

/// URIs for the Chunk Distribution Network feature.
public struct ChunkDistributionUris: Codable, Sendable {
    /// URI for pulling chunks from the stream.
    public let get: String
    /// URI for publishing chunks to the stream.
    public let set: String

    public init(get: String, set: String) {
        self.get = get
        self.set = set
    }
}

public enum RpcLightClientExecutionProofRequest: Codable, Sendable {
    case case0(sender_id: AccountId, transaction_hash: CryptoHash, type: String)
    case case01(receiver_id: AccountId, type: String, receipt_id: CryptoHash)
}

/// Describes the cost of creating an access key.
public struct AccessKeyCreationConfigView: Codable, Sendable {
    /// Base cost of creating a full access access-key.
    public let full_access_cost: Fee
    /// Base cost of creating an access-key restricted to specific functions.
    public let function_call_cost: Fee
    /// Cost per byte of method_names of creating a restricted access-key.
    public let function_call_cost_per_byte: Fee

    public init(full_access_cost: Fee, function_call_cost: Fee, function_call_cost_per_byte: Fee) {
        self.full_access_cost = full_access_cost
        self.function_call_cost = function_call_cost
        self.function_call_cost_per_byte = function_call_cost_per_byte
    }
}

public enum JsonRpcResponse_for_RpcTransactionResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcTransactionResponse)
    case case01(error: RpcError)
}

public struct RpcCongestionLevelResponse: Codable, Sendable {
    public let congestion_level: String

    public init(congestion_level: String) {
        self.congestion_level = congestion_level
    }
}

/// A view of the account
public struct AccountView: Codable, Sendable {
    public let amount: NearToken
    public let code_hash: CryptoHash
    public let global_contract_account_id: String?
    public let global_contract_hash: String?
    public let locked: NearToken
    /// TODO(2271): deprecated.
    public let storage_paid_at: UInt64?
    public let storage_usage: UInt64

    public init(amount: NearToken, code_hash: CryptoHash, global_contract_account_id: String?, global_contract_hash: String?, locked: NearToken, storage_paid_at: UInt64?, storage_usage: UInt64) {
        self.amount = amount
        self.code_hash = code_hash
        self.global_contract_account_id = global_contract_account_id
        self.global_contract_hash = global_contract_hash
        self.locked = locked
        self.storage_paid_at = storage_paid_at
        self.storage_usage = storage_usage
    }
}

/// Account info for validators
public struct AccountInfo: Codable, Sendable {
    public let account_id: AccountId
    public let amount: NearToken
    public let public_key: PublicKey

    public init(account_id: AccountId, amount: NearToken, public_key: PublicKey) {
        self.account_id = account_id
        self.amount = amount
        self.public_key = public_key
    }
}

public enum JsonRpcResponse_for_RpcStatusResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcStatusResponse)
    case case01(error: RpcError)
}

public struct JsonRpcRequest_for_broadcast_tx_commit: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcSendTransactionRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcSendTransactionRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// Configures how to dump state to external storage.
public struct DumpConfig: Codable, Sendable {
    /// Location of a json file with credentials allowing access to the bucket.
    public let credentials_file: String?
    /// How often to check if a new epoch has started.
    /// Feel free to set to `None`, defaults are sensible.
    public let iteration_delay: String?
    /// Specifies where to write the obtained state parts.
    public let location: ExternalStorageLocation
    /// Use in case a node that dumps state to the external storage
    /// gets in trouble.
    public let restart_dump_for_shards: [ShardId]?

    public init(credentials_file: String?, iteration_delay: String?, location: ExternalStorageLocation, restart_dump_for_shards: [ShardId]?) {
        self.credentials_file = credentials_file
        self.iteration_delay = iteration_delay
        self.location = location
        self.restart_dump_for_shards = restart_dump_for_shards
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_light_client_proof: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcLightClientExecutionProofRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcLightClientExecutionProofRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct JsonRpcRequest_for_block_effects: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcStateChangesInBlockRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcStateChangesInBlockRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// Contains main info about the chunk.
public struct ChunkHeaderView: Codable, Sendable {
    public let balance_burnt: NearToken
    public let bandwidth_requests: String?
    public let chunk_hash: CryptoHash
    public let congestion_info: String?
    public let encoded_length: UInt64
    public let encoded_merkle_root: CryptoHash
    public let gas_limit: NearGas
    public let gas_used: NearGas
    public let height_created: UInt64
    public let height_included: UInt64
    public let outcome_root: CryptoHash
    public let outgoing_receipts_root: CryptoHash
    public let prev_block_hash: CryptoHash
    public let prev_state_root: CryptoHash
    /// TODO(2271): deprecated.
    public let rent_paid: NearToken?
    public let shard_id: ShardId
    public let signature: Signature
    public let tx_root: CryptoHash
    public let validator_proposals: [ValidatorStakeView]
    /// TODO(2271): deprecated.
    public let validator_reward: NearToken?

    public init(balance_burnt: NearToken, bandwidth_requests: String?, chunk_hash: CryptoHash, congestion_info: String?, encoded_length: UInt64, encoded_merkle_root: CryptoHash, gas_limit: NearGas, gas_used: NearGas, height_created: UInt64, height_included: UInt64, outcome_root: CryptoHash, outgoing_receipts_root: CryptoHash, prev_block_hash: CryptoHash, prev_state_root: CryptoHash, rent_paid: NearToken?, shard_id: ShardId, signature: Signature, tx_root: CryptoHash, validator_proposals: [ValidatorStakeView], validator_reward: NearToken?) {
        self.balance_burnt = balance_burnt
        self.bandwidth_requests = bandwidth_requests
        self.chunk_hash = chunk_hash
        self.congestion_info = congestion_info
        self.encoded_length = encoded_length
        self.encoded_merkle_root = encoded_merkle_root
        self.gas_limit = gas_limit
        self.gas_used = gas_used
        self.height_created = height_created
        self.height_included = height_included
        self.outcome_root = outcome_root
        self.outgoing_receipts_root = outgoing_receipts_root
        self.prev_block_hash = prev_block_hash
        self.prev_state_root = prev_state_root
        self.rent_paid = rent_paid
        self.shard_id = shard_id
        self.signature = signature
        self.tx_root = tx_root
        self.validator_proposals = validator_proposals
        self.validator_reward = validator_reward
    }
}

/// Configuration for a cloud-based archival reader.
public struct CloudArchivalReaderConfig: Codable, Sendable {
    /// Configures the external storage used by the archival node.
    public let cloud_storage: CloudStorageConfig

    public init(cloud_storage: CloudStorageConfig) {
        self.cloud_storage = cloud_storage
    }
}

public enum RpcProtocolConfigRequest: Codable, Sendable {
    case case0(block_id: BlockId)
    case case01(finality: Finality)
    case case02(sync_checkpoint: SyncCheckpoint)
}

/// A versioned struct that contains all information needed to assign accounts to shards.
/// 
/// Because of re-sharding, the chain may use different shard layout to split shards at different
/// times. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each
/// epoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since
/// re-sharding has only happened once. It is stored as part of genesis config, see
/// default_simple_nightshade_shard_layout() Below is an overview for some important
/// functionalities of ShardLayout interface.
public enum ShardLayout: Codable, Sendable {
    case case0(V0: ShardLayoutV0)
    case case01(V1: ShardLayoutV1)
    case case02(V2: ShardLayoutV2)
}

public struct TransferAction: Codable, Sendable {
    public let deposit: NearToken

    public init(deposit: NearToken) {
        self.deposit = deposit
    }
}

public struct JsonRpcRequest_for_broadcast_tx_async: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcSendTransactionRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcSendTransactionRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// This type is used to mark keys (arrays of bytes) that are queried from store.
/// 
/// NOTE: Currently, this type is only used in the view_client and RPC to be able to transparently
/// pretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).
public typealias StoreKey = String

public enum JsonRpcResponse_for_RpcQueryResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcQueryResponse)
    case case01(error: RpcError)
}

public enum JsonRpcResponse_for_RpcReceiptResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcReceiptResponse)
    case case01(error: RpcError)
}

public enum RpcQueryResponse: Codable, Sendable {
    case case0
    case case1
    case case2
    case case3
    case case4
    case case5
}

public struct GasKeyView: Codable, Sendable {
    public let balance: NearToken
    public let num_nonces: UInt32
    public let permission: AccessKeyPermissionView

    public init(balance: NearToken, num_nonces: UInt32, permission: AccessKeyPermissionView) {
        self.balance = balance
        self.num_nonces = num_nonces
        self.permission = permission
    }
}

public enum GlobalContractIdentifier: Codable, Sendable {
    case case0(CodeHash: CryptoHash)
    case case01(AccountId: AccountId)
}

/// Contexts in which `StorageError::MissingTrieValue` error might occur.
public enum MissingTrieValueContext: Codable, Sendable {
    case trieiterator
    case trieprefetchingstorage
    case triememorypartialstorage
    case triestorage
}

public struct ShardLayoutV1: Codable, Sendable {
    /// The boundary accounts are the accounts on boundaries between shards.
    /// Each shard contains a range of accounts from one boundary account to
    /// another - or the smallest or largest account possible. The total
    /// number of shards is equal to the number of boundary accounts plus 1.
    public let boundary_accounts: [AccountId]
    /// Maps shards from the last shard layout to shards that it splits to in this shard layout,
    /// Useful for constructing states for the shards.
    /// None for the genesis shard layout
    public let shards_split_map: [[ShardId]]?
    /// Maps shard in this shard layout to their parent shard
    /// Since shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap
    public let to_parent_shard_map: [ShardId]?
    /// Version of the shard layout, this is useful for uniquely identify the shard layout
    public let version: UInt32

    public init(boundary_accounts: [AccountId], shards_split_map: [[ShardId]]?, to_parent_shard_map: [ShardId]?, version: UInt32) {
        self.boundary_accounts = boundary_accounts
        self.shards_split_map = shards_split_map
        self.to_parent_shard_map = to_parent_shard_map
        self.version = version
    }
}

public struct RpcStateChangesInBlockResponse: Codable, Sendable {
    public let block_hash: CryptoHash
    public let changes: [StateChangeWithCauseView]

    public init(block_hash: CryptoHash, changes: [StateChangeWithCauseView]) {
        self.block_hash = block_hash
        self.changes = changes
    }
}

/// Contains the split storage information.
public struct RpcSplitStorageInfoResponse: Codable, Sendable {
    public let cold_head_height: UInt64?
    public let final_head_height: UInt64?
    public let head_height: UInt64?
    public let hot_db_kind: String?
}

/// A view of the contract code.
public struct ContractCodeView: Codable, Sendable {
    public let code_base64: String
    public let hash: CryptoHash

    public init(code_base64: String, hash: CryptoHash) {
        self.code_base64 = code_base64
        self.hash = hash
    }
}

public struct PeerInfoView: Codable, Sendable {
    public let account_id: String?
    public let addr: String
    public let archival: Bool
    public let block_hash: String?
    public let connection_established_time_millis: UInt64
    public let height: UInt64?
    public let is_highest_block_invalid: Bool
    public let is_outbound_peer: Bool
    public let last_time_peer_requested_millis: UInt64
    public let last_time_received_message_millis: UInt64
    /// Connection nonce.
    public let nonce: UInt64
    public let peer_id: PublicKey
    public let received_bytes_per_sec: UInt64
    public let sent_bytes_per_sec: UInt64
    public let tracked_shards: [ShardId]

    public init(account_id: String?, addr: String, archival: Bool, block_hash: String?, connection_established_time_millis: UInt64, height: UInt64?, is_highest_block_invalid: Bool, is_outbound_peer: Bool, last_time_peer_requested_millis: UInt64, last_time_received_message_millis: UInt64, nonce: UInt64, peer_id: PublicKey, received_bytes_per_sec: UInt64, sent_bytes_per_sec: UInt64, tracked_shards: [ShardId]) {
        self.account_id = account_id
        self.addr = addr
        self.archival = archival
        self.block_hash = block_hash
        self.connection_established_time_millis = connection_established_time_millis
        self.height = height
        self.is_highest_block_invalid = is_highest_block_invalid
        self.is_outbound_peer = is_outbound_peer
        self.last_time_peer_requested_millis = last_time_peer_requested_millis
        self.last_time_received_message_millis = last_time_received_message_millis
        self.nonce = nonce
        self.peer_id = peer_id
        self.received_bytes_per_sec = received_bytes_per_sec
        self.sent_bytes_per_sec = sent_bytes_per_sec
        self.tracked_shards = tracked_shards
    }
}

public struct RpcReceiptResponse: Codable, Sendable {
    public let predecessor_id: AccountId
    public let priority: UInt64?
    public let receipt: ReceiptEnumView
    public let receipt_id: CryptoHash
    public let receiver_id: AccountId

    public init(predecessor_id: AccountId, priority: UInt64?, receipt: ReceiptEnumView, receipt_id: CryptoHash, receiver_id: AccountId) {
        self.predecessor_id = predecessor_id
        self.priority = priority
        self.receipt = receipt
        self.receipt_id = receipt_id
        self.receiver_id = receiver_id
    }
}

public enum JsonRpcResponse_for_RpcNetworkInfoResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcNetworkInfoResponse)
    case case01(error: RpcError)
}

public struct FunctionCallAction: Codable, Sendable {
    public let args: String
    public let deposit: NearToken
    public let gas: NearGas
    public let method_name: String

    public init(args: String, deposit: NearToken, gas: NearGas, method_name: String) {
        self.args = args
        self.deposit = deposit
        self.gas = gas
        self.method_name = method_name
    }
}

/// The structure describes configuration for creation of new accounts.
public struct AccountCreationConfigView: Codable, Sendable {
    /// The minimum length of the top-level account ID that is allowed to be created by any account.
    public let min_allowed_top_level_account_length: String
    /// The account ID of the account registrar. This account ID allowed to create top-level
    /// accounts of any valid length.
    public let registrar_account_id: AccountId

    public init(min_allowed_top_level_account_length: String, registrar_account_id: AccountId) {
        self.min_allowed_top_level_account_length = min_allowed_top_level_account_length
        self.registrar_account_id = registrar_account_id
    }
}

/// Error returned in the ExecutionOutcome in case of failure
public enum TxExecutionError: Codable, Sendable {
    case case0(ActionError: ActionError)
    case case01(InvalidTxError: InvalidTxError)
}

public struct JsonRpcRequest_for_changes: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcStateChangesInBlockByTypeRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcStateChangesInBlockByTypeRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct JsonRpcRequest_for_send_tx: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcSendTransactionRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcSendTransactionRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct RpcStatusResponse: Codable, Sendable {
    /// Unique chain id.
    public let chain_id: String
    /// Information about last blocks, network, epoch and chain & chunk info.
    public let detailed_debug_status: String?
    /// Genesis hash of the chain.
    public let genesis_hash: CryptoHash
    /// Latest protocol version that this client supports.
    public let latest_protocol_version: UInt32
    /// Deprecated; same as `validator_public_key` which you should use instead.
    public let node_key: String?
    /// Public key of the node.
    public let node_public_key: PublicKey
    /// Currently active protocol version.
    public let protocol_version: UInt32
    /// Address for RPC server.  None if node doesn't have RPC endpoint enabled.
    public let rpc_addr: String?
    /// Sync status of the node.
    public let sync_info: StatusSyncInfo
    /// Uptime of the node.
    public let uptime_sec: Int64
    /// Validator id of the node
    public let validator_account_id: String?
    /// Public key of the validator.
    public let validator_public_key: String?
    /// Current epoch validators.
    public let validators: [ValidatorInfo]
    /// Binary version.
    public let version: Version

    public init(chain_id: String, detailed_debug_status: String?, genesis_hash: CryptoHash, latest_protocol_version: UInt32, node_key: String?, node_public_key: PublicKey, protocol_version: UInt32, rpc_addr: String?, sync_info: StatusSyncInfo, uptime_sec: Int64, validator_account_id: String?, validator_public_key: String?, validators: [ValidatorInfo], version: Version) {
        self.chain_id = chain_id
        self.detailed_debug_status = detailed_debug_status
        self.genesis_hash = genesis_hash
        self.latest_protocol_version = latest_protocol_version
        self.node_key = node_key
        self.node_public_key = node_public_key
        self.protocol_version = protocol_version
        self.rpc_addr = rpc_addr
        self.sync_info = sync_info
        self.uptime_sec = uptime_sec
        self.validator_account_id = validator_account_id
        self.validator_public_key = validator_public_key
        self.validators = validators
        self.version = version
    }
}

/// Contains main info about the block.
public struct BlockHeaderView: Codable, Sendable {
    public let approvals: [String]
    public let block_body_hash: String?
    public let block_merkle_root: CryptoHash
    public let block_ordinal: UInt64?
    public let challenges_result: [SlashedValidator]
    public let challenges_root: CryptoHash
    public let chunk_endorsements: [[String]]?
    public let chunk_headers_root: CryptoHash
    public let chunk_mask: [Bool]
    public let chunk_receipts_root: CryptoHash
    public let chunk_tx_root: CryptoHash
    public let chunks_included: UInt64
    public let epoch_id: CryptoHash
    public let epoch_sync_data_hash: String?
    public let gas_price: NearToken
    public let hash: CryptoHash
    public let height: UInt64
    public let last_ds_final_block: CryptoHash
    public let last_final_block: CryptoHash
    public let latest_protocol_version: UInt32
    public let next_bp_hash: CryptoHash
    public let next_epoch_id: CryptoHash
    public let outcome_root: CryptoHash
    /// The hash of the previous Block
    public let prev_hash: CryptoHash
    public let prev_height: UInt64?
    public let prev_state_root: CryptoHash
    public let random_value: CryptoHash
    /// TODO(2271): deprecated.
    public let rent_paid: NearToken?
    /// Signature of the block producer.
    public let signature: Signature
    /// Legacy json number. Should not be used.
    public let timestamp: UInt64
    public let timestamp_nanosec: String
    public let total_supply: NearToken
    public let validator_proposals: [ValidatorStakeView]
    /// TODO(2271): deprecated.
    public let validator_reward: NearToken?

    public init(approvals: [String], block_body_hash: String?, block_merkle_root: CryptoHash, block_ordinal: UInt64?, challenges_result: [SlashedValidator], challenges_root: CryptoHash, chunk_endorsements: [[String]]?, chunk_headers_root: CryptoHash, chunk_mask: [Bool], chunk_receipts_root: CryptoHash, chunk_tx_root: CryptoHash, chunks_included: UInt64, epoch_id: CryptoHash, epoch_sync_data_hash: String?, gas_price: NearToken, hash: CryptoHash, height: UInt64, last_ds_final_block: CryptoHash, last_final_block: CryptoHash, latest_protocol_version: UInt32, next_bp_hash: CryptoHash, next_epoch_id: CryptoHash, outcome_root: CryptoHash, prev_hash: CryptoHash, prev_height: UInt64?, prev_state_root: CryptoHash, random_value: CryptoHash, rent_paid: NearToken?, signature: Signature, timestamp: UInt64, timestamp_nanosec: String, total_supply: NearToken, validator_proposals: [ValidatorStakeView], validator_reward: NearToken?) {
        self.approvals = approvals
        self.block_body_hash = block_body_hash
        self.block_merkle_root = block_merkle_root
        self.block_ordinal = block_ordinal
        self.challenges_result = challenges_result
        self.challenges_root = challenges_root
        self.chunk_endorsements = chunk_endorsements
        self.chunk_headers_root = chunk_headers_root
        self.chunk_mask = chunk_mask
        self.chunk_receipts_root = chunk_receipts_root
        self.chunk_tx_root = chunk_tx_root
        self.chunks_included = chunks_included
        self.epoch_id = epoch_id
        self.epoch_sync_data_hash = epoch_sync_data_hash
        self.gas_price = gas_price
        self.hash = hash
        self.height = height
        self.last_ds_final_block = last_ds_final_block
        self.last_final_block = last_final_block
        self.latest_protocol_version = latest_protocol_version
        self.next_bp_hash = next_bp_hash
        self.next_epoch_id = next_epoch_id
        self.outcome_root = outcome_root
        self.prev_hash = prev_hash
        self.prev_height = prev_height
        self.prev_state_root = prev_state_root
        self.random_value = random_value
        self.rent_paid = rent_paid
        self.signature = signature
        self.timestamp = timestamp
        self.timestamp_nanosec = timestamp_nanosec
        self.total_supply = total_supply
        self.validator_proposals = validator_proposals
        self.validator_reward = validator_reward
    }
}

/// Describes the cost of creating a specific action, `Action`. Includes all variants.
public struct ActionCreationConfigView: Codable, Sendable {
    /// Base cost of adding a key.
    public let add_key_cost: AccessKeyCreationConfigView
    /// Base cost of creating an account.
    public let create_account_cost: Fee
    /// Base cost for processing a delegate action.
    /// 
    /// This is on top of the costs for the actions inside the delegate action.
    public let delegate_cost: Fee
    /// Base cost of deleting an account.
    public let delete_account_cost: Fee
    /// Base cost of deleting a key.
    public let delete_key_cost: Fee
    /// Base cost of deploying a contract.
    public let deploy_contract_cost: Fee
    /// Cost per byte of deploying a contract.
    public let deploy_contract_cost_per_byte: Fee
    /// Base cost of calling a function.
    public let function_call_cost: Fee
    /// Cost per byte of method name and arguments of calling a function.
    public let function_call_cost_per_byte: Fee
    /// Base cost of staking.
    public let stake_cost: Fee
    /// Base cost of making a transfer.
    public let transfer_cost: Fee

    public init(add_key_cost: AccessKeyCreationConfigView, create_account_cost: Fee, delegate_cost: Fee, delete_account_cost: Fee, delete_key_cost: Fee, deploy_contract_cost: Fee, deploy_contract_cost_per_byte: Fee, function_call_cost: Fee, function_call_cost_per_byte: Fee, stake_cost: Fee, transfer_cost: Fee) {
        self.add_key_cost = add_key_cost
        self.create_account_cost = create_account_cost
        self.delegate_cost = delegate_cost
        self.delete_account_cost = delete_account_cost
        self.delete_key_cost = delete_key_cost
        self.deploy_contract_cost = deploy_contract_cost
        self.deploy_contract_cost_per_byte = deploy_contract_cost_per_byte
        self.function_call_cost = function_call_cost
        self.function_call_cost_per_byte = function_call_cost_per_byte
        self.stake_cost = stake_cost
        self.transfer_cost = transfer_cost
    }
}

public struct DeterministicStateInitAction: Codable, Sendable {
    public let deposit: NearToken
    public let state_init: DeterministicAccountStateInit

    public init(deposit: NearToken, state_init: DeterministicAccountStateInit) {
        self.deposit = deposit
        self.state_init = state_init
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_receipt: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcReceiptRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcReceiptRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public typealias SignedTransaction = String

/// Describes the error for validating a receipt.
public enum ReceiptValidationError: Codable, Sendable {
    case case0(InvalidPredecessorId: String)
    case case01(InvalidReceiverId: String)
    case case02(InvalidSignerId: String)
    case case03(InvalidDataReceiverId: String)
    case case04(ReturnedValueLengthExceeded: String)
    case case05(NumberInputDataDependenciesExceeded: String)
    case case06(ActionsValidation: ActionsValidationError)
    case case07(ReceiptSizeExceeded: String)
}

/// See crate::types::StateChangeCause for details.
public enum StateChangeCauseView: Codable, Sendable {
    case case0(type: String)
    case case01(type: String)
    case case02(tx_hash: CryptoHash, type: String)
    case case03(receipt_hash: CryptoHash, type: String)
    case case04(receipt_hash: CryptoHash, type: String)
    case case05(receipt_hash: CryptoHash, type: String)
    case case06(receipt_hash: CryptoHash, type: String)
    case case07(type: String)
    case case08(type: String)
    case case09(type: String)
    case case010(type: String)
}

public struct JsonRpcRequest_for_chunk: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcChunkRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcChunkRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct RpcLightClientBlockProofRequest: Codable, Sendable {
    public let block_hash: CryptoHash
    public let light_client_head: CryptoHash

    public init(block_hash: CryptoHash, light_client_head: CryptoHash) {
        self.block_hash = block_hash
        self.light_client_head = light_client_head
    }
}

/// A state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).
public struct RpcLightClientNextBlockResponse: Codable, Sendable {
    public let approvals_after_next: [String]?
    /// Inner part of the block header that gets hashed, split into two parts, one that is sent
    ///    to light clients, and the rest
    public let inner_lite: BlockHeaderInnerLiteView?
    public let inner_rest_hash: CryptoHash?
    public let next_block_inner_hash: CryptoHash?
    public let next_bps: [ValidatorStakeView]?
    public let prev_block_hash: CryptoHash?
}

public struct LightClientBlockLiteView: Codable, Sendable {
    public let inner_lite: BlockHeaderInnerLiteView
    public let inner_rest_hash: CryptoHash
    public let prev_block_hash: CryptoHash

    public init(inner_lite: BlockHeaderInnerLiteView, inner_rest_hash: CryptoHash, prev_block_hash: CryptoHash) {
        self.inner_lite = inner_lite
        self.inner_rest_hash = inner_rest_hash
        self.prev_block_hash = prev_block_hash
    }
}

public enum RpcValidatorRequest: Codable, Sendable {
    case latest
    case case0(epoch_id: EpochId)
    case case01(block_id: BlockId)
}

public struct ExecutionOutcomeView: Codable, Sendable {
    /// The id of the account on which the execution happens. For transaction this is signer_id,
    /// for receipt this is receiver_id.
    public let executor_id: AccountId
    /// The amount of the gas burnt by the given transaction or receipt.
    public let gas_burnt: NearGas
    /// Logs from this transaction or receipt.
    public let logs: [String]
    /// Execution metadata, versioned
    public let metadata: ExecutionMetadataView?
    /// Receipt IDs generated by this transaction or receipt.
    public let receipt_ids: [CryptoHash]
    /// Execution status. Contains the result in case of successful execution.
    public let status: ExecutionStatusView
    /// The amount of tokens burnt corresponding to the burnt gas amount.
    /// This value doesn't always equal to the `gas_burnt` multiplied by the gas price, because
    /// the prepaid gas price might be lower than the actual gas price and it creates a deficit.
    /// `tokens_burnt` also contains the penalty subtracted from refunds, while
    /// `gas_burnt` only contains the gas that we actually burn for the execution.
    public let tokens_burnt: NearToken

    public init(executor_id: AccountId, gas_burnt: NearGas, logs: [String], metadata: ExecutionMetadataView?, receipt_ids: [CryptoHash], status: ExecutionStatusView, tokens_burnt: NearToken) {
        self.executor_id = executor_id
        self.gas_burnt = gas_burnt
        self.logs = logs
        self.metadata = metadata
        self.receipt_ids = receipt_ids
        self.status = status
        self.tokens_burnt = tokens_burnt
    }
}

public enum JsonRpcResponse_for_RpcLightClientBlockProofResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcLightClientBlockProofResponse)
    case case01(error: RpcError)
}

/// Reasons for removing a validator from the validator set.
public enum ValidatorKickoutReason: Codable, Sendable {
    case _unusedslashed
    case case0(NotEnoughBlocks: String)
    case case01(NotEnoughChunks: String)
    case unstaked
    case case02(NotEnoughStake: String)
    case didnotgetaseat
    case case03(NotEnoughChunkEndorsements: String)
    case case04(ProtocolVersionTooOld: String)
}

/// Item of the state, key and value are serialized in base64 and proof for inclusion of given state item.
public struct StateItem: Codable, Sendable {
    public let key: StoreKey
    public let value: StoreValue

    public init(key: StoreKey, value: StoreValue) {
        self.key = key
        self.value = value
    }
}

public struct NextEpochValidatorInfo: Codable, Sendable {
    public let account_id: AccountId
    public let public_key: PublicKey
    public let shards: [ShardId]
    public let stake: NearToken

    public init(account_id: AccountId, public_key: PublicKey, shards: [ShardId], stake: NearToken) {
        self.account_id = account_id
        self.public_key = public_key
        self.shards = shards
        self.stake = stake
    }
}

public struct DataReceiverView: Codable, Sendable {
    public let data_id: CryptoHash
    public let receiver_id: AccountId

    public init(data_id: CryptoHash, receiver_id: AccountId) {
        self.data_id = data_id
        self.receiver_id = receiver_id
    }
}

public enum JsonRpcResponse_for_RpcLightClientNextBlockResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcLightClientNextBlockResponse)
    case case01(error: RpcError)
}

public struct NetworkInfoView: Codable, Sendable {
    public let connected_peers: [PeerInfoView]
    public let known_producers: [KnownProducerView]
    public let num_connected_peers: String
    public let peer_max_count: UInt32
    public let tier1_accounts_data: [AccountDataView]
    public let tier1_accounts_keys: [PublicKey]
    public let tier1_connections: [PeerInfoView]

    public init(connected_peers: [PeerInfoView], known_producers: [KnownProducerView], num_connected_peers: String, peer_max_count: UInt32, tier1_accounts_data: [AccountDataView], tier1_accounts_keys: [PublicKey], tier1_connections: [PeerInfoView]) {
        self.connected_peers = connected_peers
        self.known_producers = known_producers
        self.num_connected_peers = num_connected_peers
        self.peer_max_count = peer_max_count
        self.tier1_accounts_data = tier1_accounts_data
        self.tier1_accounts_keys = tier1_accounts_keys
        self.tier1_connections = tier1_connections
    }
}

public struct ReceiptView: Codable, Sendable {
    public let predecessor_id: AccountId
    public let priority: UInt64?
    public let receipt: ReceiptEnumView
    public let receipt_id: CryptoHash
    public let receiver_id: AccountId

    public init(predecessor_id: AccountId, priority: UInt64?, receipt: ReceiptEnumView, receipt_id: CryptoHash, receiver_id: AccountId) {
        self.predecessor_id = predecessor_id
        self.priority = priority
        self.receipt = receipt
        self.receipt_id = receipt_id
        self.receiver_id = receiver_id
    }
}

/// Configures the external storage used by the archival node.
public struct CloudStorageConfig: Codable, Sendable {
    /// Location of a json file with credentials allowing access to the bucket.
    public let credentials_file: String?
    /// The storage to persist the archival data.
    public let storage: ExternalStorageLocation

    public init(credentials_file: String?, storage: ExternalStorageLocation) {
        self.credentials_file = credentials_file
        self.storage = storage
    }
}

/// Error that can occur while preparing or executing Wasm smart-contract.
public enum PrepareError: Codable, Sendable {
    case serialization
    case deserialization
    case internalmemorydeclared
    case gasinstrumentation
    case stackheightinstrumentation
    case instantiate
    case memory
    case toomanyfunctions
    case toomanylocals
    case toomanytables
    case toomanytableelements
}

public typealias SyncCheckpoint = String

public enum JsonRpcResponse_for_RpcClientConfigResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcClientConfigResponse)
    case case01(error: RpcError)
}

/// A kind of a trap happened during execution of a binary
public enum WasmTrap: Codable, Sendable {
    case unreachable
    case incorrectcallindirectsignature
    case memoryoutofbounds
    case callindirectoob
    case illegalarithmetic
    case misalignedatomicaccess
    case indirectcalltonull
    case stackoverflow
    case generictrap
}

public struct ExternalStorageConfig: Codable, Sendable {
    /// The number of attempts the node will make to obtain a part from peers in
    /// the network before it fetches from external storage.
    public let external_storage_fallback_threshold: UInt64?
    /// Location of state parts.
    public let location: ExternalStorageLocation
    /// When fetching state parts from external storage, throttle fetch requests
    /// to this many concurrent requests.
    public let num_concurrent_requests: String?
    /// During catchup, the node will use a different number of concurrent requests
    /// to reduce the performance impact of state sync.
    public let num_concurrent_requests_during_catchup: String?

    public init(external_storage_fallback_threshold: UInt64?, location: ExternalStorageLocation, num_concurrent_requests: String?, num_concurrent_requests_during_catchup: String?) {
        self.external_storage_fallback_threshold = external_storage_fallback_threshold
        self.location = location
        self.num_concurrent_requests = num_concurrent_requests
        self.num_concurrent_requests_during_catchup = num_concurrent_requests_during_catchup
    }
}

public struct ExecutionMetadataView: Codable, Sendable {
    public let gas_profile: [CostGasUsed]?
    public let version: UInt32

    public init(gas_profile: [CostGasUsed]?, version: UInt32) {
        self.gas_profile = gas_profile
        self.version = version
    }
}

/// The configuration for congestion control. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)
public struct CongestionControlConfigView: Codable, Sendable {
    /// How much gas the chosen allowed shard can send to a 100% congested shard.
    /// 
    /// See [`CongestionControlConfig`] for more details.
    public let allowed_shard_outgoing_gas: NearGas
    /// How much gas in delayed receipts of a shard is 100% incoming congestion.
    /// 
    /// See [`CongestionControlConfig`] for more details.
    public let max_congestion_incoming_gas: NearGas
    /// How much memory space of all delayed and buffered receipts in a shard is
    /// considered 100% congested.
    /// 
    /// See [`CongestionControlConfig`] for more details.
    public let max_congestion_memory_consumption: UInt64
    /// How many missed chunks in a row in a shard is considered 100% congested.
    public let max_congestion_missed_chunks: UInt64
    /// How much gas in outgoing buffered receipts of a shard is 100% congested.
    /// 
    /// Outgoing congestion contributes to overall congestion, which reduces how
    /// much other shards are allowed to forward to this shard.
    public let max_congestion_outgoing_gas: NearGas
    /// The maximum amount of gas attached to receipts a shard can forward to
    /// another shard per chunk.
    /// 
    /// See [`CongestionControlConfig`] for more details.
    public let max_outgoing_gas: NearGas
    /// The maximum amount of gas in a chunk spent on converting new transactions to
    /// receipts.
    /// 
    /// See [`CongestionControlConfig`] for more details.
    public let max_tx_gas: NearGas
    /// The minimum gas each shard can send to a shard that is not fully congested.
    /// 
    /// See [`CongestionControlConfig`] for more details.
    public let min_outgoing_gas: NearGas
    /// The minimum amount of gas in a chunk spent on converting new transactions
    /// to receipts, as long as the receiving shard is not congested.
    /// 
    /// See [`CongestionControlConfig`] for more details.
    public let min_tx_gas: NearGas
    /// Large size limit for outgoing receipts to a shard, used when it's safe
    /// to send a lot of receipts without making the state witness too large.
    /// It limits the total sum of outgoing receipts, not individual receipts.
    public let outgoing_receipts_big_size_limit: UInt64
    /// The standard size limit for outgoing receipts aimed at a single shard.
    /// This limit is pretty small to keep the size of source_receipt_proofs under control.
    /// It limits the total sum of outgoing receipts, not individual receipts.
    public let outgoing_receipts_usual_size_limit: UInt64
    /// How much congestion a shard can tolerate before it stops all shards from
    /// accepting new transactions with the receiver set to the congested shard.
    public let reject_tx_congestion_threshold: String

    public init(allowed_shard_outgoing_gas: NearGas, max_congestion_incoming_gas: NearGas, max_congestion_memory_consumption: UInt64, max_congestion_missed_chunks: UInt64, max_congestion_outgoing_gas: NearGas, max_outgoing_gas: NearGas, max_tx_gas: NearGas, min_outgoing_gas: NearGas, min_tx_gas: NearGas, outgoing_receipts_big_size_limit: UInt64, outgoing_receipts_usual_size_limit: UInt64, reject_tx_congestion_threshold: String) {
        self.allowed_shard_outgoing_gas = allowed_shard_outgoing_gas
        self.max_congestion_incoming_gas = max_congestion_incoming_gas
        self.max_congestion_memory_consumption = max_congestion_memory_consumption
        self.max_congestion_missed_chunks = max_congestion_missed_chunks
        self.max_congestion_outgoing_gas = max_congestion_outgoing_gas
        self.max_outgoing_gas = max_outgoing_gas
        self.max_tx_gas = max_tx_gas
        self.min_outgoing_gas = min_outgoing_gas
        self.min_tx_gas = min_tx_gas
        self.outgoing_receipts_big_size_limit = outgoing_receipts_big_size_limit
        self.outgoing_receipts_usual_size_limit = outgoing_receipts_usual_size_limit
        self.reject_tx_congestion_threshold = reject_tx_congestion_threshold
    }
}

public struct RpcProtocolConfigResponse: Codable, Sendable {
    /// Expected number of hidden validators per shard.
    public let avg_hidden_validator_seats_per_shard: [UInt64]
    /// Threshold for kicking out block producers, between 0 and 100.
    public let block_producer_kickout_threshold: String
    /// ID of the blockchain. This must be unique for every blockchain.
    /// If your testnet blockchains do not have unique chain IDs, you will have a bad time.
    public let chain_id: String
    /// Threshold for kicking out chunk producers, between 0 and 100.
    public let chunk_producer_kickout_threshold: String
    /// Threshold for kicking out nodes which are only chunk validators, between 0 and 100.
    public let chunk_validator_only_kickout_threshold: String
    /// Enable dynamic re-sharding.
    public let dynamic_resharding: Bool
    /// Epoch length counted in block heights.
    public let epoch_length: UInt64
    /// Fishermen stake threshold.
    public let fishermen_threshold: NearToken
    /// Initial gas limit.
    public let gas_limit: NearGas
    /// Gas price adjustment rate
    public let gas_price_adjustment_rate: [Int32]
    /// Height of genesis block.
    public let genesis_height: UInt64
    /// Official time of blockchain start.
    public let genesis_time: String
    /// Maximum gas price.
    public let max_gas_price: NearToken
    /// Maximum inflation on the total supply every epoch.
    public let max_inflation_rate: [Int32]
    /// Max stake percentage of the validators we will kick out.
    public let max_kickout_stake_perc: String
    /// Minimum gas price. It is also the initial gas price.
    public let min_gas_price: NearToken
    /// The minimum stake required for staking is last seat price divided by this number.
    public let minimum_stake_divisor: UInt64
    /// The lowest ratio s/s_total any block producer can have.
    /// See <https://github.com/near/NEPs/pull/167> for details
    public let minimum_stake_ratio: [Int32]
    /// The minimum number of validators each shard must have
    public let minimum_validators_per_shard: UInt64
    /// Number of block producer seats at genesis.
    public let num_block_producer_seats: UInt64
    /// Defines number of shards and number of block producer seats per each shard at genesis.
    public let num_block_producer_seats_per_shard: [UInt64]
    /// Expected number of blocks per year
    public let num_blocks_per_year: UInt64
    /// Online maximum threshold above which validator gets full reward.
    public let online_max_threshold: [Int32]
    /// Online minimum threshold below which validator doesn't receive reward.
    public let online_min_threshold: [Int32]
    /// Protocol treasury rate
    public let protocol_reward_rate: [Int32]
    /// Protocol treasury account
    public let protocol_treasury_account: AccountId
    /// Threshold of stake that needs to indicate that they ready for upgrade.
    public let protocol_upgrade_stake_threshold: [Int32]
    /// Current Protocol Version
    public let protocol_version: UInt32
    /// Runtime configuration (mostly economics constants).
    public let runtime_config: RuntimeConfigView
    /// Layout information regarding how to split accounts to shards
    public let shard_layout: ShardLayout
    /// If true, shuffle the chunk producers across shards. In other words, if
    /// the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents
    /// the set of chunk producers for shard `i`, if this flag were true, the
    /// shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.
    public let shuffle_shard_assignment_for_chunk_producers: Bool
    /// Number of target chunk validator mandates for each shard.
    public let target_validator_mandates_per_shard: UInt64
    /// Number of blocks for which a given transaction is valid
    public let transaction_validity_period: UInt64

    public init(avg_hidden_validator_seats_per_shard: [UInt64], block_producer_kickout_threshold: String, chain_id: String, chunk_producer_kickout_threshold: String, chunk_validator_only_kickout_threshold: String, dynamic_resharding: Bool, epoch_length: UInt64, fishermen_threshold: NearToken, gas_limit: NearGas, gas_price_adjustment_rate: [Int32], genesis_height: UInt64, genesis_time: String, max_gas_price: NearToken, max_inflation_rate: [Int32], max_kickout_stake_perc: String, min_gas_price: NearToken, minimum_stake_divisor: UInt64, minimum_stake_ratio: [Int32], minimum_validators_per_shard: UInt64, num_block_producer_seats: UInt64, num_block_producer_seats_per_shard: [UInt64], num_blocks_per_year: UInt64, online_max_threshold: [Int32], online_min_threshold: [Int32], protocol_reward_rate: [Int32], protocol_treasury_account: AccountId, protocol_upgrade_stake_threshold: [Int32], protocol_version: UInt32, runtime_config: RuntimeConfigView, shard_layout: ShardLayout, shuffle_shard_assignment_for_chunk_producers: Bool, target_validator_mandates_per_shard: UInt64, transaction_validity_period: UInt64) {
        self.avg_hidden_validator_seats_per_shard = avg_hidden_validator_seats_per_shard
        self.block_producer_kickout_threshold = block_producer_kickout_threshold
        self.chain_id = chain_id
        self.chunk_producer_kickout_threshold = chunk_producer_kickout_threshold
        self.chunk_validator_only_kickout_threshold = chunk_validator_only_kickout_threshold
        self.dynamic_resharding = dynamic_resharding
        self.epoch_length = epoch_length
        self.fishermen_threshold = fishermen_threshold
        self.gas_limit = gas_limit
        self.gas_price_adjustment_rate = gas_price_adjustment_rate
        self.genesis_height = genesis_height
        self.genesis_time = genesis_time
        self.max_gas_price = max_gas_price
        self.max_inflation_rate = max_inflation_rate
        self.max_kickout_stake_perc = max_kickout_stake_perc
        self.min_gas_price = min_gas_price
        self.minimum_stake_divisor = minimum_stake_divisor
        self.minimum_stake_ratio = minimum_stake_ratio
        self.minimum_validators_per_shard = minimum_validators_per_shard
        self.num_block_producer_seats = num_block_producer_seats
        self.num_block_producer_seats_per_shard = num_block_producer_seats_per_shard
        self.num_blocks_per_year = num_blocks_per_year
        self.online_max_threshold = online_max_threshold
        self.online_min_threshold = online_min_threshold
        self.protocol_reward_rate = protocol_reward_rate
        self.protocol_treasury_account = protocol_treasury_account
        self.protocol_upgrade_stake_threshold = protocol_upgrade_stake_threshold
        self.protocol_version = protocol_version
        self.runtime_config = runtime_config
        self.shard_layout = shard_layout
        self.shuffle_shard_assignment_for_chunk_producers = shuffle_shard_assignment_for_chunk_producers
        self.target_validator_mandates_per_shard = target_validator_mandates_per_shard
        self.transaction_validity_period = transaction_validity_period
    }
}

/// Data structure for semver version and github tag or commit.
public struct Version: Codable, Sendable {
    public let build: String
    public let commit: String
    public let rustc_version: String?
    public let version: String

    public init(build: String, commit: String, rustc_version: String?, version: String) {
        self.build = build
        self.commit = commit
        self.rustc_version = rustc_version
        self.version = version
    }
}

public typealias NearToken = String

public struct JsonRpcRequest_for_health: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcHealthRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcHealthRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct RpcMaintenanceWindowsRequest: Codable, Sendable {
    public let account_id: AccountId

    public init(account_id: AccountId) {
        self.account_id = account_id
    }
}

public typealias LogSummaryStyle = String

/// An action which stakes signer_id tokens and setup's validator public key
public struct StakeAction: Codable, Sendable {
    /// Validator key which will be used to sign transactions on behalf of signer_id
    public let public_key: PublicKey
    /// Amount of tokens to stake.
    public let stake: NearToken

    public init(public_key: PublicKey, stake: NearToken) {
        self.public_key = public_key
        self.stake = stake
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_protocol_config: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcProtocolConfigRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcProtocolConfigRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public enum GlobalContractDeployMode: Codable, Sendable {
    case codehash
    case accountid
}

/// Access key provides limited access to an account. Each access key belongs to some account and
/// is identified by a unique (within the account) public key. One account may have large number of
/// access keys. Access keys allow to act on behalf of the account by restricting transactions
/// that can be issued.
/// `account_id,public_key` is a key in the state
public struct AccessKey: Codable, Sendable {
    /// Nonce for this access key, used for tx nonce generation. When access key is created, nonce
    /// is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.
    /// See <https://github.com/near/nearcore/issues/3779> for more details.
    public let nonce: UInt64
    /// Defines permissions for this access key.
    public let permission: AccessKeyPermission

    public init(nonce: UInt64, permission: AccessKeyPermission) {
        self.nonce = nonce
        self.permission = permission
    }
}

public enum RpcTransactionResponse: Codable, Sendable {
    case case0
    case case1
}

/// Config for the Chunk Distribution Network feature.
/// This allows nodes to push and pull chunks from a central stream.
/// The two benefits of this approach are: (1) less request/response traffic
/// on the peer-to-peer network and (2) lower latency for RPC nodes indexing the chain.
public struct ChunkDistributionNetworkConfig: Codable, Sendable {
    public let enabled: Bool
    public let uris: ChunkDistributionUris

    public init(enabled: Bool, uris: ChunkDistributionUris) {
        self.enabled = enabled
        self.uris = uris
    }
}

public enum RpcTransactionStatusRequest: Codable, Sendable {
    case case0(signed_tx_base64: SignedTransaction)
    case case01(sender_account_id: AccountId, tx_hash: CryptoHash)
}

public struct RpcStateChangesInBlockByTypeResponse: Codable, Sendable {
    public let block_hash: CryptoHash
    public let changes: [StateChangeKindView]

    public init(block_hash: CryptoHash, changes: [StateChangeKindView]) {
        self.block_hash = block_hash
        self.changes = changes
    }
}

public enum DeterministicAccountStateInit: Codable, Sendable {
    case case0(V1: DeterministicAccountStateInitV1)
}

public struct JsonRpcRequest_for_block: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcBlockRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcBlockRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct StateSyncConfig: Codable, Sendable {
    public let concurrency: SyncConcurrency?
    /// `none` value disables state dump to external storage.
    public let dump: String?
    /// Zstd compression level for state parts.
    public let parts_compression_lvl: Int32?
    public let sync: SyncConfig?
}

public enum RpcChunkRequest: Codable, Sendable {
    case blockshardid(shard_id: ShardId, block_id: BlockId)
    case chunkhash(chunk_id: CryptoHash)
}

/// Supported external storage backends and their minimal config.
public enum ExternalStorageLocation: Codable, Sendable {
    case case0(S3: String)
    case case01(Filesystem: String)
    case case02(GCS: String)
}

public struct RpcGasPriceResponse: Codable, Sendable {
    public let gas_price: NearToken

    public init(gas_price: NearToken) {
        self.gas_price = gas_price
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_light_client_block_proof: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcLightClientBlockProofRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcLightClientBlockProofRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// Describes the permission scope for an access key. Whether it is a function call or a full access key.
public enum AccessKeyPermissionView: Codable, Sendable {
    case fullaccess
    case case0(FunctionCall: String)
}

/// Epoch identifier -- wrapped hash, to make it easier to distinguish.
/// EpochId of epoch T is the hash of last block in T-2
/// EpochId of first two epochs is 0
public struct EpochId: Codable, Sendable {
    public init() {}
}

public enum TxExecutionStatus: Codable, Sendable {
    case none
    case included
    case executed_optimistic
    case included_final
    case executed
    case final
}

/// ClientConfig where some fields can be updated at runtime.
public struct RpcClientConfigResponse: Codable, Sendable {
    /// Not clear old data, set `true` for archive nodes.
    public let archive: Bool
    /// Horizon at which instead of fetching block, fetch full state.
    public let block_fetch_horizon: UInt64
    /// Behind this horizon header fetch kicks in.
    public let block_header_fetch_horizon: UInt64
    /// Duration to check for producing / skipping block.
    public let block_production_tracking_delay: [UInt64]
    /// Time between check to perform catchup.
    public let catchup_step_period: [UInt64]
    /// Chain id for status.
    public let chain_id: String
    /// Optional config for the Chunk Distribution Network feature.
    /// If set to `None` then this node does not participate in the Chunk Distribution Network.
    /// Nodes not participating will still function fine, but possibly with higher
    /// latency due to the need of requesting chunks over the peer-to-peer network.
    public let chunk_distribution_network: String?
    /// Time between checking to re-request chunks.
    public let chunk_request_retry_period: [UInt64]
    /// Number of threads for ChunkValidationActor pool.
    public let chunk_validation_threads: String
    /// Multiplier for the wait time for all chunks to be received.
    public let chunk_wait_mult: [Int32]
    /// Number of threads to execute background migration work in client.
    public let client_background_migration_threads: String
    /// Configuration for a cloud-based archival reader.
    public let cloud_archival_reader: String?
    /// Configuration for a cloud-based archival writer. If this config is present, the writer is enabled and
    /// writes chunk-related data based on the tracked shards.
    public let cloud_archival_writer: String?
    /// Time between running doomslug timer.
    public let doomslug_step_period: [UInt64]
    public let enable_multiline_logging: Bool
    /// Re-export storage layer statistics as prometheus metrics.
    public let enable_statistics_export: Bool
    /// Epoch length.
    public let epoch_length: UInt64
    /// Options for epoch sync.
    public let epoch_sync: EpochSyncConfig
    /// Graceful shutdown at expected block height.
    public let expected_shutdown: MutableConfigValue
    /// Garbage collection configuration.
    public let gc: GCConfig
    /// Expected increase of header head height per second during header sync
    public let header_sync_expected_height_per_second: UInt64
    /// How much time to wait after initial header sync
    public let header_sync_initial_timeout: [UInt64]
    /// How much time to wait after some progress is made in header sync
    public let header_sync_progress_timeout: [UInt64]
    /// How much time to wait before banning a peer in header sync if sync is too slow
    public let header_sync_stall_ban_timeout: [UInt64]
    /// Period between logging summary information.
    public let log_summary_period: [UInt64]
    /// Enable coloring of the logs
    public let log_summary_style: LogSummaryStyle
    /// Maximum wait for approvals before producing block.
    public let max_block_production_delay: [UInt64]
    /// Maximum duration before skipping given height.
    public let max_block_wait_delay: [UInt64]
    /// Max burnt gas per view method.  If present, overrides value stored in
    /// genesis file.  The value only affects the RPCs without influencing the
    /// protocol thus changing it per-node doesn’t affect the blockchain.
    public let max_gas_burnt_view: String?
    /// Minimum duration before producing block.
    public let min_block_production_delay: [UInt64]
    /// Minimum number of peers to start syncing.
    public let min_num_peers: String
    /// Number of block producer seats
    public let num_block_producer_seats: UInt64
    /// Maximum size of state witnesses in the OrphanStateWitnessPool.
    /// 
    /// We keep only orphan witnesses which are smaller than this size.
    /// This limits the maximum memory usage of OrphanStateWitnessPool.
    public let orphan_state_witness_max_size: UInt64
    /// OrphanStateWitnessPool keeps instances of ChunkStateWitness which can't be processed
    /// because the previous block isn't available. The witnesses wait in the pool until the
    /// required block appears. This variable controls how many witnesses can be stored in the pool.
    public let orphan_state_witness_pool_size: String
    /// Limit the time of adding transactions to a chunk.
    /// A node produces a chunk by adding transactions from the transaction pool until
    /// some limit is reached. This time limit ensures that adding transactions won't take
    /// longer than the specified duration, which helps to produce the chunk quickly.
    public let produce_chunk_add_transactions_time_limit: String
    /// Produce empty blocks, use `false` for testing.
    public let produce_empty_blocks: Bool
    /// Determines whether client should exit if the protocol version is not supported
    /// for the next or next next epoch.
    public let protocol_version_check: ProtocolVersionCheckConfig
    public let resharding_config: MutableConfigValue
    /// Listening rpc port for status.
    public let rpc_addr: String?
    /// Save observed instances of invalid ChunkStateWitness to the database in DBCol::InvalidChunkStateWitnesses.
    /// Saving invalid witnesses is useful for analysis and debugging.
    /// This option can cause extra load on the database and is not recommended for production use.
    public let save_invalid_witnesses: Bool
    /// Save observed instances of ChunkStateWitness to the database in DBCol::LatestChunkStateWitnesses.
    /// Saving the latest witnesses is useful for analysis and debugging.
    /// This option can cause extra load on the database and is not recommended for production use.
    public let save_latest_witnesses: Bool
    /// save_trie_changes should be set to true iff
    /// - archive if false - non-archival nodes need trie changes to perform garbage collection
    /// - archive is true, cold_store is configured and migration to split_storage is finished - node
    /// working in split storage mode needs trie changes in order to do garbage collection on hot.
    public let save_trie_changes: Bool
    /// Whether to persist transaction outcomes to disk or not.
    public let save_tx_outcomes: Bool
    /// Whether to persist partial chunk parts for untracked shards or not.
    public let save_untracked_partial_chunks_parts: Bool
    /// Skip waiting for sync (for testing or single node testnet).
    public let skip_sync_wait: Bool
    /// Number of threads for StateRequestActor pool.
    public let state_request_server_threads: String
    /// Number of seconds between state requests for view client.
    /// Throttling window for state requests (headers and parts).
    public let state_request_throttle_period: [UInt64]
    /// Maximum number of state requests served per throttle period
    public let state_requests_per_throttle_period: String
    /// Options for syncing state.
    public let state_sync: StateSyncConfig
    /// Whether to use the State Sync mechanism.
    /// If disabled, the node will do Block Sync instead of State Sync.
    public let state_sync_enabled: Bool
    /// Additional waiting period after a failed request to external storage
    public let state_sync_external_backoff: [UInt64]
    /// How long to wait for a response from centralized state sync
    public let state_sync_external_timeout: [UInt64]
    /// How long to wait for a response from p2p state sync
    public let state_sync_p2p_timeout: [UInt64]
    /// How long to wait after a failed state sync request
    public let state_sync_retry_backoff: [UInt64]
    /// How often to check that we are not out of sync.
    public let sync_check_period: [UInt64]
    /// Sync height threshold: below this difference in height don't start syncing.
    public let sync_height_threshold: UInt64
    /// Maximum number of block requests to send to peers to sync
    public let sync_max_block_requests: String
    /// While syncing, how long to check for each step.
    public let sync_step_period: [UInt64]
    public let tracked_shards_config: TrackedShardsConfig
    /// Limit of the size of per-shard transaction pool measured in bytes. If not set, the size
    /// will be unbounded.
    public let transaction_pool_size_limit: UInt64?
    public let transaction_request_handler_threads: String
    /// Upper bound of the byte size of contract state that is still viewable. None is no limit
    public let trie_viewer_state_size_limit: UInt64?
    /// Time to persist Accounts Id in the router without removing them.
    public let ttl_account_id_router: [UInt64]
    /// If the node is not a chunk producer within that many blocks, then route
    /// to upcoming chunk producers.
    public let tx_routing_height_horizon: UInt64
    /// Version of the binary.
    public let version: Version
    /// Number of threads for ViewClientActor pool.
    public let view_client_threads: String

    public init(archive: Bool, block_fetch_horizon: UInt64, block_header_fetch_horizon: UInt64, block_production_tracking_delay: [UInt64], catchup_step_period: [UInt64], chain_id: String, chunk_distribution_network: String?, chunk_request_retry_period: [UInt64], chunk_validation_threads: String, chunk_wait_mult: [Int32], client_background_migration_threads: String, cloud_archival_reader: String?, cloud_archival_writer: String?, doomslug_step_period: [UInt64], enable_multiline_logging: Bool, enable_statistics_export: Bool, epoch_length: UInt64, epoch_sync: EpochSyncConfig, expected_shutdown: MutableConfigValue, gc: GCConfig, header_sync_expected_height_per_second: UInt64, header_sync_initial_timeout: [UInt64], header_sync_progress_timeout: [UInt64], header_sync_stall_ban_timeout: [UInt64], log_summary_period: [UInt64], log_summary_style: LogSummaryStyle, max_block_production_delay: [UInt64], max_block_wait_delay: [UInt64], max_gas_burnt_view: String?, min_block_production_delay: [UInt64], min_num_peers: String, num_block_producer_seats: UInt64, orphan_state_witness_max_size: UInt64, orphan_state_witness_pool_size: String, produce_chunk_add_transactions_time_limit: String, produce_empty_blocks: Bool, protocol_version_check: ProtocolVersionCheckConfig, resharding_config: MutableConfigValue, rpc_addr: String?, save_invalid_witnesses: Bool, save_latest_witnesses: Bool, save_trie_changes: Bool, save_tx_outcomes: Bool, save_untracked_partial_chunks_parts: Bool, skip_sync_wait: Bool, state_request_server_threads: String, state_request_throttle_period: [UInt64], state_requests_per_throttle_period: String, state_sync: StateSyncConfig, state_sync_enabled: Bool, state_sync_external_backoff: [UInt64], state_sync_external_timeout: [UInt64], state_sync_p2p_timeout: [UInt64], state_sync_retry_backoff: [UInt64], sync_check_period: [UInt64], sync_height_threshold: UInt64, sync_max_block_requests: String, sync_step_period: [UInt64], tracked_shards_config: TrackedShardsConfig, transaction_pool_size_limit: UInt64?, transaction_request_handler_threads: String, trie_viewer_state_size_limit: UInt64?, ttl_account_id_router: [UInt64], tx_routing_height_horizon: UInt64, version: Version, view_client_threads: String) {
        self.archive = archive
        self.block_fetch_horizon = block_fetch_horizon
        self.block_header_fetch_horizon = block_header_fetch_horizon
        self.block_production_tracking_delay = block_production_tracking_delay
        self.catchup_step_period = catchup_step_period
        self.chain_id = chain_id
        self.chunk_distribution_network = chunk_distribution_network
        self.chunk_request_retry_period = chunk_request_retry_period
        self.chunk_validation_threads = chunk_validation_threads
        self.chunk_wait_mult = chunk_wait_mult
        self.client_background_migration_threads = client_background_migration_threads
        self.cloud_archival_reader = cloud_archival_reader
        self.cloud_archival_writer = cloud_archival_writer
        self.doomslug_step_period = doomslug_step_period
        self.enable_multiline_logging = enable_multiline_logging
        self.enable_statistics_export = enable_statistics_export
        self.epoch_length = epoch_length
        self.epoch_sync = epoch_sync
        self.expected_shutdown = expected_shutdown
        self.gc = gc
        self.header_sync_expected_height_per_second = header_sync_expected_height_per_second
        self.header_sync_initial_timeout = header_sync_initial_timeout
        self.header_sync_progress_timeout = header_sync_progress_timeout
        self.header_sync_stall_ban_timeout = header_sync_stall_ban_timeout
        self.log_summary_period = log_summary_period
        self.log_summary_style = log_summary_style
        self.max_block_production_delay = max_block_production_delay
        self.max_block_wait_delay = max_block_wait_delay
        self.max_gas_burnt_view = max_gas_burnt_view
        self.min_block_production_delay = min_block_production_delay
        self.min_num_peers = min_num_peers
        self.num_block_producer_seats = num_block_producer_seats
        self.orphan_state_witness_max_size = orphan_state_witness_max_size
        self.orphan_state_witness_pool_size = orphan_state_witness_pool_size
        self.produce_chunk_add_transactions_time_limit = produce_chunk_add_transactions_time_limit
        self.produce_empty_blocks = produce_empty_blocks
        self.protocol_version_check = protocol_version_check
        self.resharding_config = resharding_config
        self.rpc_addr = rpc_addr
        self.save_invalid_witnesses = save_invalid_witnesses
        self.save_latest_witnesses = save_latest_witnesses
        self.save_trie_changes = save_trie_changes
        self.save_tx_outcomes = save_tx_outcomes
        self.save_untracked_partial_chunks_parts = save_untracked_partial_chunks_parts
        self.skip_sync_wait = skip_sync_wait
        self.state_request_server_threads = state_request_server_threads
        self.state_request_throttle_period = state_request_throttle_period
        self.state_requests_per_throttle_period = state_requests_per_throttle_period
        self.state_sync = state_sync
        self.state_sync_enabled = state_sync_enabled
        self.state_sync_external_backoff = state_sync_external_backoff
        self.state_sync_external_timeout = state_sync_external_timeout
        self.state_sync_p2p_timeout = state_sync_p2p_timeout
        self.state_sync_retry_backoff = state_sync_retry_backoff
        self.sync_check_period = sync_check_period
        self.sync_height_threshold = sync_height_threshold
        self.sync_max_block_requests = sync_max_block_requests
        self.sync_step_period = sync_step_period
        self.tracked_shards_config = tracked_shards_config
        self.transaction_pool_size_limit = transaction_pool_size_limit
        self.transaction_request_handler_threads = transaction_request_handler_threads
        self.trie_viewer_state_size_limit = trie_viewer_state_size_limit
        self.ttl_account_id_router = ttl_account_id_router
        self.tx_routing_height_horizon = tx_routing_height_horizon
        self.version = version
        self.view_client_threads = view_client_threads
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_changes_in_block: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcStateChangesInBlockRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcStateChangesInBlockRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct Range_of_uint64: Codable, Sendable {
    public let end: UInt64
    public let start: UInt64

    public init(end: UInt64, start: UInt64) {
        self.end = end
        self.start = start
    }
}

/// Errors which may occur during working with trie storages, storing
/// trie values (trie nodes and state values) by their hashes.
public enum StorageError: Codable, Sendable {
    case storageinternalerror
    case case0(MissingTrieValue: MissingTrieValue)
    case unexpectedtrievalue
    case case01(StorageInconsistentState: String)
    case case02(FlatStorageBlockNotSupported: String)
    case case03(MemTrieLoadingError: String)
}

/// Describes different fees for the runtime
public struct RuntimeFeesConfigView: Codable, Sendable {
    /// Describes the cost of creating a certain action, `Action`. Includes all variants.
    public let action_creation_config: ActionCreationConfigView
    /// Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost
    /// of actions.
    /// - `send` cost is burned when a receipt is created using `promise_create` or
    ///     `promise_batch_create`
    /// - `exec` cost is burned when the receipt is being executed.
    public let action_receipt_creation_config: Fee
    /// Fraction of the burnt gas to reward to the contract account for execution.
    public let burnt_gas_reward: [Int32]
    /// Describes the cost of creating a data receipt, `DataReceipt`.
    public let data_receipt_creation_config: DataReceiptCreationConfigView
    /// Pessimistic gas price inflation ratio.
    public let pessimistic_gas_price_inflation_ratio: [Int32]
    /// Describes fees for storage.
    public let storage_usage_config: StorageUsageConfigView

    public init(action_creation_config: ActionCreationConfigView, action_receipt_creation_config: Fee, burnt_gas_reward: [Int32], data_receipt_creation_config: DataReceiptCreationConfigView, pessimistic_gas_price_inflation_ratio: [Int32], storage_usage_config: StorageUsageConfigView) {
        self.action_creation_config = action_creation_config
        self.action_receipt_creation_config = action_receipt_creation_config
        self.burnt_gas_reward = burnt_gas_reward
        self.data_receipt_creation_config = data_receipt_creation_config
        self.pessimistic_gas_price_inflation_ratio = pessimistic_gas_price_inflation_ratio
        self.storage_usage_config = storage_usage_config
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_validators_ordered: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcValidatorsOrderedRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcValidatorsOrderedRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// The shard identifier. It may be an arbitrary number - it does not need to be
/// a number in the range 0..NUM_SHARDS. The shard ids do not need to be
/// sequential or contiguous.
/// 
/// The shard id is wrapped in a new type to prevent the old pattern of using
/// indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition
/// if fully complete it potentially may be simplified to a regular type alias.
public typealias ShardId = UInt64

/// A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).
public struct BlockHeaderInnerLiteView: Codable, Sendable {
    /// The merkle root of all the block hashes
    public let block_merkle_root: CryptoHash
    /// The epoch to which the block that is the current known head belongs
    public let epoch_id: CryptoHash
    public let height: UInt64
    /// The hash of the block producers set for the next epoch
    public let next_bp_hash: CryptoHash
    /// The epoch that will follow the current epoch
    public let next_epoch_id: CryptoHash
    public let outcome_root: CryptoHash
    public let prev_state_root: CryptoHash
    /// Legacy json number. Should not be used.
    public let timestamp: UInt64
    public let timestamp_nanosec: String

    public init(block_merkle_root: CryptoHash, epoch_id: CryptoHash, height: UInt64, next_bp_hash: CryptoHash, next_epoch_id: CryptoHash, outcome_root: CryptoHash, prev_state_root: CryptoHash, timestamp: UInt64, timestamp_nanosec: String) {
        self.block_merkle_root = block_merkle_root
        self.epoch_id = epoch_id
        self.height = height
        self.next_bp_hash = next_bp_hash
        self.next_epoch_id = next_epoch_id
        self.outcome_root = outcome_root
        self.prev_state_root = prev_state_root
        self.timestamp = timestamp
        self.timestamp_nanosec = timestamp_nanosec
    }
}

/// Describes access key permission scope and nonce.
public struct AccessKeyView: Codable, Sendable {
    public let nonce: UInt64
    public let permission: AccessKeyPermissionView

    public init(nonce: UInt64, permission: AccessKeyPermissionView) {
        self.nonce = nonce
        self.permission = permission
    }
}

/// An error happened during Action execution
public struct ActionError: Codable, Sendable {
    /// Index of the failed action in the transaction.
    /// Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`
    public let index: UInt64?
    /// The kind of ActionError happened
    public let kind: ActionErrorKind

    public init(index: UInt64?, kind: ActionErrorKind) {
        self.index = index
        self.kind = kind
    }
}

/// It is a [serializable view] of [`StateChangesRequest`].
/// 
/// [serializable view]: ./index.html
/// [`StateChangesRequest`]: ../types/struct.StateChangesRequest.html
public enum RpcStateChangesInBlockByTypeRequest: Codable, Sendable {
    case case0
    case case1
    case case2
    case case3
    case case4
    case case5
    case case6
    case case7
    case case8
    case case9
    case case10
    case case11
    case case12
    case case13
    case case14
    case case15
    case case16
    case case17
    case case18
    case case19
    case case20
}

public struct StatusSyncInfo: Codable, Sendable {
    public let earliest_block_hash: String?
    public let earliest_block_height: UInt64?
    public let earliest_block_time: String?
    public let epoch_id: String?
    public let epoch_start_height: UInt64?
    public let latest_block_hash: CryptoHash
    public let latest_block_height: UInt64
    public let latest_block_time: String
    public let latest_state_root: CryptoHash
    public let syncing: Bool

    public init(earliest_block_hash: String?, earliest_block_height: UInt64?, earliest_block_time: String?, epoch_id: String?, epoch_start_height: UInt64?, latest_block_hash: CryptoHash, latest_block_height: UInt64, latest_block_time: String, latest_state_root: CryptoHash, syncing: Bool) {
        self.earliest_block_hash = earliest_block_hash
        self.earliest_block_height = earliest_block_height
        self.earliest_block_time = earliest_block_time
        self.epoch_id = epoch_id
        self.epoch_start_height = epoch_start_height
        self.latest_block_hash = latest_block_hash
        self.latest_block_height = latest_block_height
        self.latest_block_time = latest_block_time
        self.latest_state_root = latest_state_root
        self.syncing = syncing
    }
}

public struct JsonRpcRequest_for_gas_price: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcGasPriceRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcGasPriceRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

/// AccountData is a piece of global state that a validator
/// signs and broadcasts to the network.
/// 
/// It is essentially the data that a validator wants to share with the network.
/// All the nodes in the network are collecting the account data
/// broadcasted by the validators.
/// Since the number of the validators is bounded and their
/// identity is known (and the maximal size of allowed AccountData is bounded)
/// the global state that is distributed in the form of AccountData is bounded
/// as well.
/// Find more information in the docs [here](https://github.com/near/nearcore/blob/560f7fc8f4b3106e0d5d46050688610b1f104ac6/chain/client/src/client.rs#L2232)
public struct AccountDataView: Codable, Sendable {
    /// Account key of the validator signing this AccountData.
    public let account_key: PublicKey
    /// ID of the node that handles the account key (aka validator key).
    public let peer_id: PublicKey
    /// Proxy nodes that are directly connected to the validator node
    /// (this list may include the validator node itself).
    /// TIER1 nodes should connect to one of the proxies to sent TIER1
    /// messages to the validator.
    public let proxies: [Tier1ProxyView]
    /// UTC timestamp of when the AccountData has been signed.
    public let timestamp: String

    public init(account_key: PublicKey, peer_id: PublicKey, proxies: [Tier1ProxyView], timestamp: String) {
        self.account_key = account_key
        self.peer_id = peer_id
        self.proxies = proxies
        self.timestamp = timestamp
    }
}

public struct JsonRpcRequest_for_genesis_config: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: GenesisConfigRequest

    public init(id: String, jsonrpc: String, method: String, params: GenesisConfigRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct JsonRpcRequest_for_maintenance_windows: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcMaintenanceWindowsRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcMaintenanceWindowsRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public enum FinalExecutionStatus: Codable, Sendable {
    case notstarted
    case started
    case case0(Failure: TxExecutionError)
    case case01(SuccessValue: String)
}

/// Information about a Producer: its account name, peer_id and a list of connected peers that
/// the node can use to send message for this producer.
public struct KnownProducerView: Codable, Sendable {
    public let account_id: AccountId
    public let next_hops: [PublicKey]?
    public let peer_id: PublicKey

    public init(account_id: AccountId, next_hops: [PublicKey]?, peer_id: PublicKey) {
        self.account_id = account_id
        self.next_hops = next_hops
        self.peer_id = peer_id
    }
}

/// Use global contract action
public struct UseGlobalContractAction: Codable, Sendable {
    public let contract_identifier: GlobalContractIdentifier

    public init(contract_identifier: GlobalContractIdentifier) {
        self.contract_identifier = contract_identifier
    }
}

/// Configuration specific to ChunkStateWitness.
public struct WitnessConfigView: Codable, Sendable {
    /// Maximum size of transactions contained inside ChunkStateWitness.
    /// 
    /// A witness contains transactions from both the previous chunk and the current one.
    /// This parameter limits the sum of sizes of transactions from both of those chunks.
    public let combined_transactions_size_limit: String
    /// Size limit for storage proof generated while executing receipts in a chunk.
    /// After this limit is reached we defer execution of any new receipts.
    public let main_storage_proof_size_soft_limit: UInt64
    /// Soft size limit of storage proof used to validate new transactions in ChunkStateWitness.
    public let new_transactions_validation_state_size_soft_limit: UInt64

    public init(combined_transactions_size_limit: String, main_storage_proof_size_soft_limit: UInt64, new_transactions_validation_state_size_soft_limit: UInt64) {
        self.combined_transactions_size_limit = combined_transactions_size_limit
        self.main_storage_proof_size_soft_limit = main_storage_proof_size_soft_limit
        self.new_transactions_validation_state_size_soft_limit = new_transactions_validation_state_size_soft_limit
    }
}

public typealias CryptoHash = String

public struct GenesisConfigRequest: Codable, Sendable {
    public init() {}
}

public struct MerklePathItem: Codable, Sendable {
    public let direction: Direction
    public let hash: CryptoHash

    public init(direction: Direction, hash: CryptoHash) {
        self.direction = direction
        self.hash = hash
    }
}

public struct ValidatorKickoutView: Codable, Sendable {
    public let account_id: AccountId
    public let reason: ValidatorKickoutReason

    public init(account_id: AccountId, reason: ValidatorKickoutReason) {
        self.account_id = account_id
        self.reason = reason
    }
}

/// Describes limits for VM and Runtime.
/// TODO #4139: consider switching to strongly-typed wrappers instead of raw quantities
public struct LimitConfig: Codable, Sendable {
    /// Whether to enforce account_id well-formed-ness where it wasn't enforced
    /// historically.
    public let account_id_validity_rules_version: AccountIdValidityRulesVersion?
    /// The initial number of memory pages.
    /// NOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages.
    public let initial_memory_pages: UInt32
    /// Max number of actions per receipt.
    public let max_actions_per_receipt: UInt64
    /// Max length of arguments in a function call action.
    public let max_arguments_length: UInt64
    /// Max contract size
    public let max_contract_size: UInt64
    /// If present, stores max number of elements in a single contract's table
    public let max_elements_per_contract_table: String?
    /// If present, stores max number of functions in one contract
    public let max_functions_number_per_contract: UInt64?
    /// Max amount of gas that can be used, excluding gas attached to promises.
    public let max_gas_burnt: NearGas
    /// Max length of any method name (without terminating character).
    public let max_length_method_name: UInt64
    /// Max length of returned data
    public let max_length_returned_data: UInt64
    /// Max storage key size
    public let max_length_storage_key: UInt64
    /// Max storage value size
    public let max_length_storage_value: UInt64
    /// If present, stores max number of locals declared globally in one contract
    public let max_locals_per_contract: UInt64?
    /// What is the maximal memory pages amount is allowed to have for a contract.
    public let max_memory_pages: UInt32
    /// Max total length of all method names (including terminating character) for a function call
    /// permission access key.
    public let max_number_bytes_method_names: UInt64
    /// Max number of input data dependencies
    public let max_number_input_data_dependencies: UInt64
    /// Maximum number of log entries.
    public let max_number_logs: UInt64
    /// Maximum number of registers that can be used simultaneously.
    /// 
    /// Note that due to an implementation quirk [read: a bug] in VMLogic, if we
    /// have this number of registers, no subsequent writes to the registers
    /// will succeed even if they replace an existing register.
    public let max_number_registers: UInt64
    /// Max number of promises that a function call can create
    public let max_promises_per_function_call_action: UInt64
    /// Max receipt size
    public let max_receipt_size: UInt64
    /// Maximum number of bytes that can be stored in a single register.
    public let max_register_size: UInt64
    /// How tall the stack is allowed to grow?
    /// 
    /// See <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost
    /// is calculated.
    public let max_stack_height: UInt32
    /// If present, stores max number of tables declared globally in one contract
    public let max_tables_per_contract: UInt32?
    /// Maximum total length in bytes of all log messages.
    public let max_total_log_length: UInt64
    /// Max total prepaid gas for all function call actions per receipt.
    public let max_total_prepaid_gas: NearGas
    /// Max transaction size
    public let max_transaction_size: UInt64
    /// Maximum number of bytes for payload passed over a yield resume.
    public let max_yield_payload_size: UInt64
    /// Hard limit on the size of storage proof generated while executing a single receipt.
    public let per_receipt_storage_proof_size_limit: String
    /// Limit of memory used by registers.
    public let registers_memory_limit: UInt64
    /// Number of blocks after which a yielded promise times out.
    public let yield_timeout_length_in_blocks: UInt64

    public init(account_id_validity_rules_version: AccountIdValidityRulesVersion?, initial_memory_pages: UInt32, max_actions_per_receipt: UInt64, max_arguments_length: UInt64, max_contract_size: UInt64, max_elements_per_contract_table: String?, max_functions_number_per_contract: UInt64?, max_gas_burnt: NearGas, max_length_method_name: UInt64, max_length_returned_data: UInt64, max_length_storage_key: UInt64, max_length_storage_value: UInt64, max_locals_per_contract: UInt64?, max_memory_pages: UInt32, max_number_bytes_method_names: UInt64, max_number_input_data_dependencies: UInt64, max_number_logs: UInt64, max_number_registers: UInt64, max_promises_per_function_call_action: UInt64, max_receipt_size: UInt64, max_register_size: UInt64, max_stack_height: UInt32, max_tables_per_contract: UInt32?, max_total_log_length: UInt64, max_total_prepaid_gas: NearGas, max_transaction_size: UInt64, max_yield_payload_size: UInt64, per_receipt_storage_proof_size_limit: String, registers_memory_limit: UInt64, yield_timeout_length_in_blocks: UInt64) {
        self.account_id_validity_rules_version = account_id_validity_rules_version
        self.initial_memory_pages = initial_memory_pages
        self.max_actions_per_receipt = max_actions_per_receipt
        self.max_arguments_length = max_arguments_length
        self.max_contract_size = max_contract_size
        self.max_elements_per_contract_table = max_elements_per_contract_table
        self.max_functions_number_per_contract = max_functions_number_per_contract
        self.max_gas_burnt = max_gas_burnt
        self.max_length_method_name = max_length_method_name
        self.max_length_returned_data = max_length_returned_data
        self.max_length_storage_key = max_length_storage_key
        self.max_length_storage_value = max_length_storage_value
        self.max_locals_per_contract = max_locals_per_contract
        self.max_memory_pages = max_memory_pages
        self.max_number_bytes_method_names = max_number_bytes_method_names
        self.max_number_input_data_dependencies = max_number_input_data_dependencies
        self.max_number_logs = max_number_logs
        self.max_number_registers = max_number_registers
        self.max_promises_per_function_call_action = max_promises_per_function_call_action
        self.max_receipt_size = max_receipt_size
        self.max_register_size = max_register_size
        self.max_stack_height = max_stack_height
        self.max_tables_per_contract = max_tables_per_contract
        self.max_total_log_length = max_total_log_length
        self.max_total_prepaid_gas = max_total_prepaid_gas
        self.max_transaction_size = max_transaction_size
        self.max_yield_payload_size = max_yield_payload_size
        self.per_receipt_storage_proof_size_limit = per_receipt_storage_proof_size_limit
        self.registers_memory_limit = registers_memory_limit
        self.yield_timeout_length_in_blocks = yield_timeout_length_in_blocks
    }
}

public typealias PublicKey = String

/// Configuration for garbage collection.
public struct GCConfig: Codable, Sendable {
    /// Maximum number of blocks to garbage collect at every garbage collection
    /// call.
    public let gc_blocks_limit: UInt64?
    /// Maximum number of height to go through at each garbage collection step
    /// when cleaning forks during garbage collection.
    public let gc_fork_clean_step: UInt64?
    /// Number of epochs for which we keep store data.
    public let gc_num_epochs_to_keep: UInt64?
    /// How often gc should be run
    public let gc_step_period: DurationAsStdSchemaProvider?
}

/// An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.
public enum NonDelegateAction: Codable, Sendable {
    case case0(CreateAccount: CreateAccountAction)
    case case01(DeployContract: DeployContractAction)
    case case02(FunctionCall: FunctionCallAction)
    case case03(Transfer: TransferAction)
    case case04(Stake: StakeAction)
    case case05(AddKey: AddKeyAction)
    case case06(DeleteKey: DeleteKeyAction)
    case case07(DeleteAccount: DeleteAccountAction)
    case case08(DeployGlobalContract: DeployGlobalContractAction)
    case case09(UseGlobalContract: UseGlobalContractAction)
    case case010(DeterministicStateInit: DeterministicStateInitAction)
}

public enum ReceiptEnumView: Codable, Sendable {
    case case0(Action: String)
    case case01(Data: String)
    case case02(GlobalContractDistribution: String)
}

/// Defines permissions for AccessKey
public enum AccessKeyPermission: Codable, Sendable {
    case case0(FunctionCall: FunctionCallPermission)
    case fullaccess
}

/// Stores the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)
public struct CongestionInfoView: Codable, Sendable {
    public let allowed_shard: String
    public let buffered_receipts_gas: String
    public let delayed_receipts_gas: String
    public let receipt_bytes: UInt64

    public init(allowed_shard: String, buffered_receipts_gas: String, delayed_receipts_gas: String, receipt_bytes: UInt64) {
        self.allowed_shard = allowed_shard
        self.buffered_receipts_gas = buffered_receipts_gas
        self.delayed_receipts_gas = delayed_receipts_gas
        self.receipt_bytes = receipt_bytes
    }
}

public typealias MutableConfigValue = String

/// Costs associated with an object that can only be sent over the network (and executed
/// by the receiver).
/// NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.
/// And `execution` fee is burned when the item is being executed.
public struct Fee: Codable, Sendable {
    /// Fee for executing the object.
    public let execution: NearGas
    /// Fee for sending an object potentially across the shards.
    public let send_not_sir: NearGas
    /// Fee for sending an object from the sender to itself, guaranteeing that it does not leave
    /// the shard.
    public let send_sir: NearGas

    public init(execution: NearGas, send_not_sir: NearGas, send_sir: NearGas) {
        self.execution = execution
        self.send_not_sir = send_not_sir
        self.send_sir = send_sir
    }
}

public struct RpcHealthRequest: Codable, Sendable {
    public init() {}
}

public enum VMKind: Codable, Sendable {
    case wasmer0
    case wasmtime
    case wasmer2
    case nearvm
}

/// Create account action
public typealias CreateAccountAction = String

/// Lists access keys
public struct AccessKeyList: Codable, Sendable {
    public let keys: [AccessKeyInfoView]

    public init(keys: [AccessKeyInfoView]) {
        self.keys = keys
    }
}

public enum JsonRpcResponse_for_RpcSplitStorageInfoResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcSplitStorageInfoResponse)
    case case01(error: RpcError)
}

public struct RpcStatusRequest: Codable, Sendable {
    public init() {}
}

/// Final execution outcome of the transaction and all of subsequent the receipts. Also includes
/// the generated receipt.
public struct FinalExecutionOutcomeWithReceiptView: Codable, Sendable {
    /// Receipts generated from the transaction
    public let receipts: [ReceiptView]
    /// The execution outcome of receipts.
    public let receipts_outcome: [ExecutionOutcomeWithIdView]
    /// Execution status defined by chain.rs:get_final_transaction_result
    /// FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet
    /// FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution
    /// FinalExecutionStatus::Failure - the result of the first leaf receipt_id
    /// FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id
    public let status: FinalExecutionStatus
    /// Signed Transaction
    public let transaction: SignedTransactionView
    /// The execution outcome of the signed transaction.
    public let transaction_outcome: ExecutionOutcomeWithIdView

    public init(receipts: [ReceiptView], receipts_outcome: [ExecutionOutcomeWithIdView], status: FinalExecutionStatus, transaction: SignedTransactionView, transaction_outcome: ExecutionOutcomeWithIdView) {
        self.receipts = receipts
        self.receipts_outcome = receipts_outcome
        self.status = status
        self.transaction = transaction
        self.transaction_outcome = transaction_outcome
    }
}

public struct SlashedValidator: Codable, Sendable {
    public let account_id: AccountId
    public let is_double_sign: Bool

    public init(account_id: AccountId, is_double_sign: Bool) {
        self.account_id = account_id
        self.is_double_sign = is_double_sign
    }
}

/// Version 1 of [`BandwidthRequest`].
public struct BandwidthRequestsV1: Codable, Sendable {
    public let requests: [BandwidthRequest]

    public init(requests: [BandwidthRequest]) {
        self.requests = requests
    }
}

/// Configuration for a cloud-based archival writer. If this config is present, the writer is enabled and
/// writes chunk-related data based on the tracked shards. This config also controls additional archival
/// behavior such as block data and polling interval.
public struct CloudArchivalWriterConfig: Codable, Sendable {
    /// Determines whether block-related data should be written to cloud storage.
    public let archive_block_data: Bool?
    /// Configures the external storage used by the archival node.
    public let cloud_storage: CloudStorageConfig
    /// Interval at which the system checks for new blocks or chunks to archive.
    public let polling_interval: DurationAsStdSchemaProvider?

    public init(archive_block_data: Bool?, cloud_storage: CloudStorageConfig, polling_interval: DurationAsStdSchemaProvider?) {
        self.archive_block_data = archive_block_data
        self.cloud_storage = cloud_storage
        self.polling_interval = polling_interval
    }
}

public enum BlockId: Codable, Sendable {
    case case0
    case case1
}

/// A shard layout that maps accounts evenly across all shards -- by calculate the hash of account
/// id and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,
/// to keep backward compatibility for some existing tests.
/// `parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout
/// a chain uses.
public struct ShardLayoutV0: Codable, Sendable {
    /// Map accounts evenly across all shards
    public let num_shards: UInt64
    /// Version of the shard layout, this is useful for uniquely identify the shard layout
    public let version: UInt32

    public init(num_shards: UInt64, version: UInt32) {
        self.num_shards = num_shards
        self.version = version
    }
}

public enum RpcStateChangesInBlockRequest: Codable, Sendable {
    case case0(block_id: BlockId)
    case case01(finality: Finality)
    case case02(sync_checkpoint: SyncCheckpoint)
}

public enum JsonRpcResponse_for_RpcProtocolConfigResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcProtocolConfigResponse)
    case case01(error: RpcError)
}

public typealias MethodResolveError = String

/// Counterpart to `ShardLayoutV2` composed of maps with string keys to aid
/// serde serialization.
public struct ShardLayoutV2: Codable, Sendable {
    public let boundary_accounts: [AccountId]
    public let id_to_index_map: String
    public let index_to_id_map: String
    public let shard_ids: [ShardId]
    public let shards_parent_map: String?
    public let shards_split_map: String?
    public let version: UInt32

    public init(boundary_accounts: [AccountId], id_to_index_map: String, index_to_id_map: String, shard_ids: [ShardId], shards_parent_map: String?, shards_split_map: String?, version: UInt32) {
        self.boundary_accounts = boundary_accounts
        self.id_to_index_map = id_to_index_map
        self.index_to_id_map = index_to_id_map
        self.shard_ids = shard_ids
        self.shards_parent_map = shards_parent_map
        self.shards_split_map = shards_split_map
        self.version = version
    }
}

/// Describes information about the current epoch validator
public struct CurrentEpochValidatorInfo: Codable, Sendable {
    public let account_id: AccountId
    public let is_slashed: Bool
    public let num_expected_blocks: UInt64
    public let num_expected_chunks: UInt64?
    /// Number of chunks this validator was expected to produce in each shard.
    /// Each entry in the array corresponds to the shard in the `shards_produced` array.
    public let num_expected_chunks_per_shard: [UInt64]?
    public let num_expected_endorsements: UInt64?
    /// Number of chunks this validator was expected to validate and endorse in each shard.
    /// Each entry in the array corresponds to the shard in the `shards_endorsed` array.
    public let num_expected_endorsements_per_shard: [UInt64]?
    public let num_produced_blocks: UInt64
    public let num_produced_chunks: UInt64?
    public let num_produced_chunks_per_shard: [UInt64]?
    public let num_produced_endorsements: UInt64?
    public let num_produced_endorsements_per_shard: [UInt64]?
    public let public_key: PublicKey
    /// Shards this validator is assigned to as chunk producer in the current epoch.
    public let shards: [ShardId]
    /// Shards this validator is assigned to as chunk validator in the current epoch.
    public let shards_endorsed: [ShardId]?
    public let stake: NearToken

    public init(account_id: AccountId, is_slashed: Bool, num_expected_blocks: UInt64, num_expected_chunks: UInt64?, num_expected_chunks_per_shard: [UInt64]?, num_expected_endorsements: UInt64?, num_expected_endorsements_per_shard: [UInt64]?, num_produced_blocks: UInt64, num_produced_chunks: UInt64?, num_produced_chunks_per_shard: [UInt64]?, num_produced_endorsements: UInt64?, num_produced_endorsements_per_shard: [UInt64]?, public_key: PublicKey, shards: [ShardId], shards_endorsed: [ShardId]?, stake: NearToken) {
        self.account_id = account_id
        self.is_slashed = is_slashed
        self.num_expected_blocks = num_expected_blocks
        self.num_expected_chunks = num_expected_chunks
        self.num_expected_chunks_per_shard = num_expected_chunks_per_shard
        self.num_expected_endorsements = num_expected_endorsements
        self.num_expected_endorsements_per_shard = num_expected_endorsements_per_shard
        self.num_produced_blocks = num_produced_blocks
        self.num_produced_chunks = num_produced_chunks
        self.num_produced_chunks_per_shard = num_produced_chunks_per_shard
        self.num_produced_endorsements = num_produced_endorsements
        self.num_produced_endorsements_per_shard = num_produced_endorsements_per_shard
        self.public_key = public_key
        self.shards = shards
        self.shards_endorsed = shards_endorsed
        self.stake = stake
    }
}

/// This struct may be returned from JSON RPC server in case of error
/// It is expected that this struct has impl From<_> all other RPC errors
/// like [RpcBlockError](crate::types::blocks::RpcBlockError)
public enum RpcError: Codable, Sendable {
    case case0(cause: RpcRequestValidationErrorKind, name: String)
    case case01(cause: String, name: String)
    case case02(cause: String, name: String)
}

/// Typed view of ExtCostsConfig to preserve JSON output field names in protocol
/// config RPC output.
public struct ExtCostsConfigView: Codable, Sendable {
    /// Base cost for multiexp
    public let alt_bn128_g1_multiexp_base: NearGas
    /// Per element cost for multiexp
    public let alt_bn128_g1_multiexp_element: NearGas
    /// Base cost for sum
    public let alt_bn128_g1_sum_base: NearGas
    /// Per element cost for sum
    public let alt_bn128_g1_sum_element: NearGas
    /// Base cost for pairing check
    public let alt_bn128_pairing_check_base: NearGas
    /// Per element cost for pairing check
    public let alt_bn128_pairing_check_element: NearGas
    /// Base cost for calling a host function.
    public let base: NearGas
    public let bls12381_g1_multiexp_base: NearGas
    public let bls12381_g1_multiexp_element: NearGas
    public let bls12381_g2_multiexp_base: NearGas
    public let bls12381_g2_multiexp_element: NearGas
    public let bls12381_map_fp2_to_g2_base: NearGas
    public let bls12381_map_fp2_to_g2_element: NearGas
    public let bls12381_map_fp_to_g1_base: NearGas
    public let bls12381_map_fp_to_g1_element: NearGas
    public let bls12381_p1_decompress_base: NearGas
    public let bls12381_p1_decompress_element: NearGas
    public let bls12381_p1_sum_base: NearGas
    public let bls12381_p1_sum_element: NearGas
    public let bls12381_p2_decompress_base: NearGas
    public let bls12381_p2_decompress_element: NearGas
    public let bls12381_p2_sum_base: NearGas
    public let bls12381_p2_sum_element: NearGas
    public let bls12381_pairing_base: NearGas
    public let bls12381_pairing_element: NearGas
    public let contract_compile_base: NearGas
    public let contract_compile_bytes: NearGas
    /// Base cost of loading a pre-compiled contract
    public let contract_loading_base: NearGas
    /// Cost per byte of loading a pre-compiled contract
    public let contract_loading_bytes: NearGas
    /// Cost of calling ecrecover
    public let ecrecover_base: NearGas
    /// Cost of getting ed25519 base
    public let ed25519_verify_base: NearGas
    /// Cost of getting ed25519 per byte
    public let ed25519_verify_byte: NearGas
    /// Cost of getting sha256 base
    public let keccak256_base: NearGas
    /// Cost of getting sha256 per byte
    public let keccak256_byte: NearGas
    /// Cost of getting sha256 base
    public let keccak512_base: NearGas
    /// Cost of getting sha256 per byte
    public let keccak512_byte: NearGas
    /// Cost for calling logging.
    public let log_base: NearGas
    /// Cost for logging per byte
    public let log_byte: NearGas
    /// Cost for calling `promise_and`
    public let promise_and_base: NearGas
    /// Cost for calling `promise_and` for each promise
    public let promise_and_per_promise: NearGas
    /// Cost for calling `promise_return`
    public let promise_return: NearGas
    /// Cost for reading trie node from memory
    public let read_cached_trie_node: NearGas
    /// Base cost for guest memory read
    public let read_memory_base: NearGas
    /// Cost for guest memory read
    public let read_memory_byte: NearGas
    /// Base cost for reading from register
    public let read_register_base: NearGas
    /// Cost for reading byte from register
    public let read_register_byte: NearGas
    /// Cost of getting ripemd160 base
    public let ripemd160_base: NearGas
    /// Cost of getting ripemd160 per message block
    public let ripemd160_block: NearGas
    /// Cost of getting sha256 base
    public let sha256_base: NearGas
    /// Cost of getting sha256 per byte
    public let sha256_byte: NearGas
    /// Storage trie check for key existence cost base
    public let storage_has_key_base: NearGas
    /// Storage trie check for key existence per key byte
    public let storage_has_key_byte: NearGas
    /// Create trie range iterator cost per byte of from key.
    public let storage_iter_create_from_byte: NearGas
    /// Create trie prefix iterator cost base
    public let storage_iter_create_prefix_base: NearGas
    /// Create trie prefix iterator cost per byte.
    public let storage_iter_create_prefix_byte: NearGas
    /// Create trie range iterator cost base
    public let storage_iter_create_range_base: NearGas
    /// Create trie range iterator cost per byte of to key.
    public let storage_iter_create_to_byte: NearGas
    /// Trie iterator per key base cost
    public let storage_iter_next_base: NearGas
    /// Trie iterator next key byte cost
    public let storage_iter_next_key_byte: NearGas
    /// Trie iterator next key byte cost
    public let storage_iter_next_value_byte: NearGas
    /// Storage trie read key overhead base cost, when doing large reads
    public let storage_large_read_overhead_base: NearGas
    /// Storage trie read key overhead  per-byte cost, when doing large reads
    public let storage_large_read_overhead_byte: NearGas
    /// Storage trie read key base cost
    public let storage_read_base: NearGas
    /// Storage trie read key per byte cost
    public let storage_read_key_byte: NearGas
    /// Storage trie read value cost per byte cost
    public let storage_read_value_byte: NearGas
    /// Remove key from trie base cost
    public let storage_remove_base: NearGas
    /// Remove key from trie per byte cost
    public let storage_remove_key_byte: NearGas
    /// Remove key from trie ret value byte cost
    public let storage_remove_ret_value_byte: NearGas
    /// Storage trie write key base cost
    public let storage_write_base: NearGas
    /// Storage trie write cost per byte of evicted value.
    public let storage_write_evicted_byte: NearGas
    /// Storage trie write key per byte cost
    public let storage_write_key_byte: NearGas
    /// Storage trie write value per byte cost
    public let storage_write_value_byte: NearGas
    /// Cost per reading trie node from DB
    public let touching_trie_node: NearGas
    /// Base cost of decoding utf16. It's used for `log_utf16`.
    public let utf16_decoding_base: NearGas
    /// Cost per byte of decoding utf16. It's used for `log_utf16`.
    public let utf16_decoding_byte: NearGas
    /// Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`.
    public let utf8_decoding_base: NearGas
    /// Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`.
    public let utf8_decoding_byte: NearGas
    /// Cost of calling `validator_stake`.
    public let validator_stake_base: NearGas
    /// Cost of calling `validator_total_stake`.
    public let validator_total_stake_base: NearGas
    /// Base cost for guest memory write
    public let write_memory_base: NearGas
    /// Cost for guest memory write per byte
    public let write_memory_byte: NearGas
    /// Base cost for writing into register
    public let write_register_base: NearGas
    /// Cost for writing byte into register
    public let write_register_byte: NearGas
    /// Base cost for creating a yield promise.
    public let yield_create_base: NearGas
    /// Per byte cost of arguments and method name.
    public let yield_create_byte: NearGas
    /// Base cost for resuming a yield receipt.
    public let yield_resume_base: NearGas
    /// Per byte cost of resume payload.
    public let yield_resume_byte: NearGas

    public init(alt_bn128_g1_multiexp_base: NearGas, alt_bn128_g1_multiexp_element: NearGas, alt_bn128_g1_sum_base: NearGas, alt_bn128_g1_sum_element: NearGas, alt_bn128_pairing_check_base: NearGas, alt_bn128_pairing_check_element: NearGas, base: NearGas, bls12381_g1_multiexp_base: NearGas, bls12381_g1_multiexp_element: NearGas, bls12381_g2_multiexp_base: NearGas, bls12381_g2_multiexp_element: NearGas, bls12381_map_fp2_to_g2_base: NearGas, bls12381_map_fp2_to_g2_element: NearGas, bls12381_map_fp_to_g1_base: NearGas, bls12381_map_fp_to_g1_element: NearGas, bls12381_p1_decompress_base: NearGas, bls12381_p1_decompress_element: NearGas, bls12381_p1_sum_base: NearGas, bls12381_p1_sum_element: NearGas, bls12381_p2_decompress_base: NearGas, bls12381_p2_decompress_element: NearGas, bls12381_p2_sum_base: NearGas, bls12381_p2_sum_element: NearGas, bls12381_pairing_base: NearGas, bls12381_pairing_element: NearGas, contract_compile_base: NearGas, contract_compile_bytes: NearGas, contract_loading_base: NearGas, contract_loading_bytes: NearGas, ecrecover_base: NearGas, ed25519_verify_base: NearGas, ed25519_verify_byte: NearGas, keccak256_base: NearGas, keccak256_byte: NearGas, keccak512_base: NearGas, keccak512_byte: NearGas, log_base: NearGas, log_byte: NearGas, promise_and_base: NearGas, promise_and_per_promise: NearGas, promise_return: NearGas, read_cached_trie_node: NearGas, read_memory_base: NearGas, read_memory_byte: NearGas, read_register_base: NearGas, read_register_byte: NearGas, ripemd160_base: NearGas, ripemd160_block: NearGas, sha256_base: NearGas, sha256_byte: NearGas, storage_has_key_base: NearGas, storage_has_key_byte: NearGas, storage_iter_create_from_byte: NearGas, storage_iter_create_prefix_base: NearGas, storage_iter_create_prefix_byte: NearGas, storage_iter_create_range_base: NearGas, storage_iter_create_to_byte: NearGas, storage_iter_next_base: NearGas, storage_iter_next_key_byte: NearGas, storage_iter_next_value_byte: NearGas, storage_large_read_overhead_base: NearGas, storage_large_read_overhead_byte: NearGas, storage_read_base: NearGas, storage_read_key_byte: NearGas, storage_read_value_byte: NearGas, storage_remove_base: NearGas, storage_remove_key_byte: NearGas, storage_remove_ret_value_byte: NearGas, storage_write_base: NearGas, storage_write_evicted_byte: NearGas, storage_write_key_byte: NearGas, storage_write_value_byte: NearGas, touching_trie_node: NearGas, utf16_decoding_base: NearGas, utf16_decoding_byte: NearGas, utf8_decoding_base: NearGas, utf8_decoding_byte: NearGas, validator_stake_base: NearGas, validator_total_stake_base: NearGas, write_memory_base: NearGas, write_memory_byte: NearGas, write_register_base: NearGas, write_register_byte: NearGas, yield_create_base: NearGas, yield_create_byte: NearGas, yield_resume_base: NearGas, yield_resume_byte: NearGas) {
        self.alt_bn128_g1_multiexp_base = alt_bn128_g1_multiexp_base
        self.alt_bn128_g1_multiexp_element = alt_bn128_g1_multiexp_element
        self.alt_bn128_g1_sum_base = alt_bn128_g1_sum_base
        self.alt_bn128_g1_sum_element = alt_bn128_g1_sum_element
        self.alt_bn128_pairing_check_base = alt_bn128_pairing_check_base
        self.alt_bn128_pairing_check_element = alt_bn128_pairing_check_element
        self.base = base
        self.bls12381_g1_multiexp_base = bls12381_g1_multiexp_base
        self.bls12381_g1_multiexp_element = bls12381_g1_multiexp_element
        self.bls12381_g2_multiexp_base = bls12381_g2_multiexp_base
        self.bls12381_g2_multiexp_element = bls12381_g2_multiexp_element
        self.bls12381_map_fp2_to_g2_base = bls12381_map_fp2_to_g2_base
        self.bls12381_map_fp2_to_g2_element = bls12381_map_fp2_to_g2_element
        self.bls12381_map_fp_to_g1_base = bls12381_map_fp_to_g1_base
        self.bls12381_map_fp_to_g1_element = bls12381_map_fp_to_g1_element
        self.bls12381_p1_decompress_base = bls12381_p1_decompress_base
        self.bls12381_p1_decompress_element = bls12381_p1_decompress_element
        self.bls12381_p1_sum_base = bls12381_p1_sum_base
        self.bls12381_p1_sum_element = bls12381_p1_sum_element
        self.bls12381_p2_decompress_base = bls12381_p2_decompress_base
        self.bls12381_p2_decompress_element = bls12381_p2_decompress_element
        self.bls12381_p2_sum_base = bls12381_p2_sum_base
        self.bls12381_p2_sum_element = bls12381_p2_sum_element
        self.bls12381_pairing_base = bls12381_pairing_base
        self.bls12381_pairing_element = bls12381_pairing_element
        self.contract_compile_base = contract_compile_base
        self.contract_compile_bytes = contract_compile_bytes
        self.contract_loading_base = contract_loading_base
        self.contract_loading_bytes = contract_loading_bytes
        self.ecrecover_base = ecrecover_base
        self.ed25519_verify_base = ed25519_verify_base
        self.ed25519_verify_byte = ed25519_verify_byte
        self.keccak256_base = keccak256_base
        self.keccak256_byte = keccak256_byte
        self.keccak512_base = keccak512_base
        self.keccak512_byte = keccak512_byte
        self.log_base = log_base
        self.log_byte = log_byte
        self.promise_and_base = promise_and_base
        self.promise_and_per_promise = promise_and_per_promise
        self.promise_return = promise_return
        self.read_cached_trie_node = read_cached_trie_node
        self.read_memory_base = read_memory_base
        self.read_memory_byte = read_memory_byte
        self.read_register_base = read_register_base
        self.read_register_byte = read_register_byte
        self.ripemd160_base = ripemd160_base
        self.ripemd160_block = ripemd160_block
        self.sha256_base = sha256_base
        self.sha256_byte = sha256_byte
        self.storage_has_key_base = storage_has_key_base
        self.storage_has_key_byte = storage_has_key_byte
        self.storage_iter_create_from_byte = storage_iter_create_from_byte
        self.storage_iter_create_prefix_base = storage_iter_create_prefix_base
        self.storage_iter_create_prefix_byte = storage_iter_create_prefix_byte
        self.storage_iter_create_range_base = storage_iter_create_range_base
        self.storage_iter_create_to_byte = storage_iter_create_to_byte
        self.storage_iter_next_base = storage_iter_next_base
        self.storage_iter_next_key_byte = storage_iter_next_key_byte
        self.storage_iter_next_value_byte = storage_iter_next_value_byte
        self.storage_large_read_overhead_base = storage_large_read_overhead_base
        self.storage_large_read_overhead_byte = storage_large_read_overhead_byte
        self.storage_read_base = storage_read_base
        self.storage_read_key_byte = storage_read_key_byte
        self.storage_read_value_byte = storage_read_value_byte
        self.storage_remove_base = storage_remove_base
        self.storage_remove_key_byte = storage_remove_key_byte
        self.storage_remove_ret_value_byte = storage_remove_ret_value_byte
        self.storage_write_base = storage_write_base
        self.storage_write_evicted_byte = storage_write_evicted_byte
        self.storage_write_key_byte = storage_write_key_byte
        self.storage_write_value_byte = storage_write_value_byte
        self.touching_trie_node = touching_trie_node
        self.utf16_decoding_base = utf16_decoding_base
        self.utf16_decoding_byte = utf16_decoding_byte
        self.utf8_decoding_base = utf8_decoding_base
        self.utf8_decoding_byte = utf8_decoding_byte
        self.validator_stake_base = validator_stake_base
        self.validator_total_stake_base = validator_total_stake_base
        self.write_memory_base = write_memory_base
        self.write_memory_byte = write_memory_byte
        self.write_register_base = write_register_base
        self.write_register_byte = write_register_byte
        self.yield_create_base = yield_create_base
        self.yield_create_byte = yield_create_byte
        self.yield_resume_base = yield_resume_base
        self.yield_resume_byte = yield_resume_byte
    }
}

public struct JsonRpcRequest_for_tx: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcTransactionStatusRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcTransactionStatusRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct DurationAsStdSchemaProvider: Codable, Sendable {
    public let nanos: Int32
    public let secs: Int64

    public init(nanos: Int32, secs: Int64) {
        self.nanos = nanos
        self.secs = secs
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_genesis_config: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: GenesisConfigRequest

    public init(id: String, jsonrpc: String, method: String, params: GenesisConfigRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public struct RpcHealthResponse: Codable, Sendable {
    public init() {}
}

/// Configures whether the node checks the next or the next next epoch for network version compatibility.
public typealias ProtocolVersionCheckConfig = String

/// Describes information about an access key including the public key.
public struct AccessKeyInfoView: Codable, Sendable {
    public let access_key: AccessKeyView
    public let public_key: PublicKey

    public init(access_key: AccessKeyView, public_key: PublicKey) {
        self.access_key = access_key
        self.public_key = public_key
    }
}

public enum ActionView: Codable, Sendable {
    case createaccount
    case case0(DeployContract: String)
    case case01(FunctionCall: String)
    case case02(Transfer: String)
    case case03(Stake: String)
    case case04(AddKey: String)
    case case05(DeleteKey: String)
    case case06(DeleteAccount: String)
    case case07(Delegate: String)
    case case08(DeployGlobalContract: String)
    case case09(DeployGlobalContractByAccountId: String)
    case case010(UseGlobalContract: String)
    case case011(UseGlobalContractByAccountId: String)
    case case012(DeterministicStateInit: String)
}

public enum JsonRpcResponse_for_RpcCongestionLevelResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcCongestionLevelResponse)
    case case01(error: RpcError)
}

public enum JsonRpcResponse_for_RpcStateChangesInBlockByTypeResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcStateChangesInBlockByTypeResponse)
    case case01(error: RpcError)
}

public struct RpcBlockResponse: Codable, Sendable {
    /// The AccountId of the author of the Block
    public let author: AccountId
    public let chunks: [ChunkHeaderView]
    public let header: BlockHeaderView

    public init(author: AccountId, chunks: [ChunkHeaderView], header: BlockHeaderView) {
        self.author = author
        self.chunks = chunks
        self.header = header
    }
}

public enum JsonRpcResponse_for_Array_of_Range_of_uint64_and_RpcError: Codable, Sendable {
    case case0(result: [Range_of_uint64])
    case case01(error: RpcError)
}

public struct RpcChunkResponse: Codable, Sendable {
    public let author: AccountId
    public let header: ChunkHeaderView
    public let receipts: [ReceiptView]
    public let transactions: [SignedTransactionView]

    public init(author: AccountId, header: ChunkHeaderView, receipts: [ReceiptView], transactions: [SignedTransactionView]) {
        self.author = author
        self.header = header
        self.receipts = receipts
        self.transactions = transactions
    }
}

public struct JsonRpcRequest_for_EXPERIMENTAL_split_storage_info: Codable, Sendable {
    public let id: String
    public let jsonrpc: String
    public let method: String
    public let params: RpcSplitStorageInfoRequest

    public init(id: String, jsonrpc: String, method: String, params: RpcSplitStorageInfoRequest) {
        self.id = id
        self.jsonrpc = jsonrpc
        self.method = method
        self.params = params
    }
}

public enum JsonRpcResponse_for_RpcStateChangesInBlockResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcStateChangesInBlockResponse)
    case case01(error: RpcError)
}

public enum JsonRpcResponse_for_RpcLightClientExecutionProofResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcLightClientExecutionProofResponse)
    case case01(error: RpcError)
}

public struct EpochSyncConfig: Codable, Sendable {
    /// If true, even if the node started from genesis, it will not perform epoch sync.
    /// There should be no reason to set this flag in production, because on both mainnet
    /// and testnet it would be infeasible to catch up from genesis without epoch sync.
    public let disable_epoch_sync_for_bootstrapping: Bool?
    /// This serves as two purposes: (1) the node will not epoch sync and instead resort to
    /// header sync, if the genesis block is within this many blocks from the current block;
    /// (2) the node will reject an epoch sync proof if the provided proof is for an epoch
    /// that is more than this many blocks behind the current block.
    public let epoch_sync_horizon: UInt64
    /// If true, the node will ignore epoch sync requests from the network. It is strongly
    /// recommended not to set this flag, because it will prevent other nodes from
    /// bootstrapping. This flag is only included as a kill-switch and may be removed in a
    /// future release. Please note that epoch sync requests are heavily rate limited and
    /// cached, and therefore should not affect the performance of the node or introduce
    /// any non-negligible increase in network traffic.
    public let ignore_epoch_sync_network_requests: Bool?
    /// Timeout for epoch sync requests. The node will continue retrying indefinitely even
    /// if this timeout is exceeded.
    public let timeout_for_epoch_sync: DurationAsStdSchemaProvider

    public init(disable_epoch_sync_for_bootstrapping: Bool?, epoch_sync_horizon: UInt64, ignore_epoch_sync_network_requests: Bool?, timeout_for_epoch_sync: DurationAsStdSchemaProvider) {
        self.disable_epoch_sync_for_bootstrapping = disable_epoch_sync_for_bootstrapping
        self.epoch_sync_horizon = epoch_sync_horizon
        self.ignore_epoch_sync_network_requests = ignore_epoch_sync_network_requests
        self.timeout_for_epoch_sync = timeout_for_epoch_sync
    }
}

public struct DetailedDebugStatus: Codable, Sendable {
    public let block_production_delay_millis: UInt64
    public let catchup_status: [CatchupStatusView]
    public let current_head_status: BlockStatusView
    public let current_header_head_status: BlockStatusView
    public let network_info: NetworkInfoView
    public let sync_status: String

    public init(block_production_delay_millis: UInt64, catchup_status: [CatchupStatusView], current_head_status: BlockStatusView, current_header_head_status: BlockStatusView, network_info: NetworkInfoView, sync_status: String) {
        self.block_production_delay_millis = block_production_delay_millis
        self.catchup_status = catchup_status
        self.current_head_status = current_head_status
        self.current_header_head_status = current_header_head_status
        self.network_info = network_info
        self.sync_status = sync_status
    }
}

public enum RpcCongestionLevelRequest: Codable, Sendable {
    case blockshardid(shard_id: ShardId, block_id: BlockId)
    case chunkhash(chunk_id: CryptoHash)
}

public struct DeleteKeyAction: Codable, Sendable {
    /// A public key associated with the access_key to be deleted.
    public let public_key: PublicKey

    public init(public_key: PublicKey) {
        self.public_key = public_key
    }
}

public struct RpcPeerInfo: Codable, Sendable {
    public let account_id: String?
    public let addr: String?
    public let id: PeerId

    public init(account_id: String?, addr: String?, id: PeerId) {
        self.account_id = account_id
        self.addr = addr
        self.id = id
    }
}

/// Peer id is the public key.
public struct PeerId: Codable, Sendable {
    public init() {}
}

public struct RpcClientConfigRequest: Codable, Sendable {
    public init() {}
}

public struct GenesisConfig: Codable, Sendable {
    /// Expected number of hidden validators per shard.
    public let avg_hidden_validator_seats_per_shard: [UInt64]
    /// Threshold for kicking out block producers, between 0 and 100.
    public let block_producer_kickout_threshold: String
    /// ID of the blockchain. This must be unique for every blockchain.
    /// If your testnet blockchains do not have unique chain IDs, you will have a bad time.
    public let chain_id: String
    /// Limits the number of shard changes in chunk producer assignments,
    /// if algorithm is able to choose assignment with better balance of
    /// number of chunk producers for shards.
    public let chunk_producer_assignment_changes_limit: UInt64?
    /// Threshold for kicking out chunk producers, between 0 and 100.
    public let chunk_producer_kickout_threshold: String
    /// Threshold for kicking out nodes which are only chunk validators, between 0 and 100.
    public let chunk_validator_only_kickout_threshold: String?
    /// Enable dynamic re-sharding.
    public let dynamic_resharding: Bool
    /// Epoch length counted in block heights.
    public let epoch_length: UInt64
    /// Fishermen stake threshold.
    public let fishermen_threshold: NearToken
    /// Initial gas limit.
    public let gas_limit: NearGas
    /// Gas price adjustment rate
    public let gas_price_adjustment_rate: [Int32]
    /// Height of genesis block.
    public let genesis_height: UInt64
    /// Official time of blockchain start.
    public let genesis_time: String
    public let max_gas_price: NearToken
    /// Maximum inflation on the total supply every epoch.
    public let max_inflation_rate: [Int32]
    /// Max stake percentage of the validators we will kick out.
    public let max_kickout_stake_perc: String?
    /// Minimum gas price. It is also the initial gas price.
    public let min_gas_price: NearToken
    /// The minimum stake required for staking is last seat price divided by this number.
    public let minimum_stake_divisor: UInt64?
    /// The lowest ratio s/s_total any block producer can have.
    /// See <https://github.com/near/NEPs/pull/167> for details
    public let minimum_stake_ratio: [Int32]?
    /// The minimum number of validators each shard must have
    public let minimum_validators_per_shard: UInt64?
    /// Number of block producer seats at genesis.
    public let num_block_producer_seats: UInt64
    /// Defines number of shards and number of block producer seats per each shard at genesis.
    /// Note: not used with protocol_feature_chunk_only_producers -- replaced by minimum_validators_per_shard
    /// Note: not used before as all block producers produce chunks for all shards
    public let num_block_producer_seats_per_shard: [UInt64]
    /// Expected number of blocks per year
    public let num_blocks_per_year: UInt64
    /// Deprecated.
    public let num_chunk_only_producer_seats: UInt64?
    /// Number of chunk producers.
    /// Don't mess it up with chunk-only producers feature which is deprecated.
    public let num_chunk_producer_seats: UInt64?
    public let num_chunk_validator_seats: UInt64?
    /// Online maximum threshold above which validator gets full reward.
    public let online_max_threshold: [Int32]?
    /// Online minimum threshold below which validator doesn't receive reward.
    public let online_min_threshold: [Int32]?
    /// Protocol treasury rate
    public let protocol_reward_rate: [Int32]
    /// Protocol treasury account
    public let protocol_treasury_account: AccountId
    /// Threshold of stake that needs to indicate that they ready for upgrade.
    public let protocol_upgrade_stake_threshold: [Int32]?
    /// Protocol version that this genesis works with.
    public let protocol_version: UInt32
    /// Layout information regarding how to split accounts to shards
    public let shard_layout: ShardLayout?
    /// If true, shuffle the chunk producers across shards. In other words, if
    /// the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents
    /// the set of chunk producers for shard `i`, if this flag were true, the
    /// shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.
    public let shuffle_shard_assignment_for_chunk_producers: Bool?
    /// Number of target chunk validator mandates for each shard.
    public let target_validator_mandates_per_shard: UInt64?
    /// Total supply of tokens at genesis.
    public let total_supply: NearToken
    /// Number of blocks for which a given transaction is valid
    public let transaction_validity_period: UInt64
    /// This is only for test purposes. We hard code some configs for mainnet and testnet
    /// in AllEpochConfig, and we want to have a way to test that code path. This flag is for that.
    /// If set to true, the node will use the same config override path as mainnet and testnet.
    public let use_production_config: Bool?
    /// List of initial validators.
    public let validators: [AccountInfo]

    public init(avg_hidden_validator_seats_per_shard: [UInt64], block_producer_kickout_threshold: String, chain_id: String, chunk_producer_assignment_changes_limit: UInt64?, chunk_producer_kickout_threshold: String, chunk_validator_only_kickout_threshold: String?, dynamic_resharding: Bool, epoch_length: UInt64, fishermen_threshold: NearToken, gas_limit: NearGas, gas_price_adjustment_rate: [Int32], genesis_height: UInt64, genesis_time: String, max_gas_price: NearToken, max_inflation_rate: [Int32], max_kickout_stake_perc: String?, min_gas_price: NearToken, minimum_stake_divisor: UInt64?, minimum_stake_ratio: [Int32]?, minimum_validators_per_shard: UInt64?, num_block_producer_seats: UInt64, num_block_producer_seats_per_shard: [UInt64], num_blocks_per_year: UInt64, num_chunk_only_producer_seats: UInt64?, num_chunk_producer_seats: UInt64?, num_chunk_validator_seats: UInt64?, online_max_threshold: [Int32]?, online_min_threshold: [Int32]?, protocol_reward_rate: [Int32], protocol_treasury_account: AccountId, protocol_upgrade_stake_threshold: [Int32]?, protocol_version: UInt32, shard_layout: ShardLayout?, shuffle_shard_assignment_for_chunk_producers: Bool?, target_validator_mandates_per_shard: UInt64?, total_supply: NearToken, transaction_validity_period: UInt64, use_production_config: Bool?, validators: [AccountInfo]) {
        self.avg_hidden_validator_seats_per_shard = avg_hidden_validator_seats_per_shard
        self.block_producer_kickout_threshold = block_producer_kickout_threshold
        self.chain_id = chain_id
        self.chunk_producer_assignment_changes_limit = chunk_producer_assignment_changes_limit
        self.chunk_producer_kickout_threshold = chunk_producer_kickout_threshold
        self.chunk_validator_only_kickout_threshold = chunk_validator_only_kickout_threshold
        self.dynamic_resharding = dynamic_resharding
        self.epoch_length = epoch_length
        self.fishermen_threshold = fishermen_threshold
        self.gas_limit = gas_limit
        self.gas_price_adjustment_rate = gas_price_adjustment_rate
        self.genesis_height = genesis_height
        self.genesis_time = genesis_time
        self.max_gas_price = max_gas_price
        self.max_inflation_rate = max_inflation_rate
        self.max_kickout_stake_perc = max_kickout_stake_perc
        self.min_gas_price = min_gas_price
        self.minimum_stake_divisor = minimum_stake_divisor
        self.minimum_stake_ratio = minimum_stake_ratio
        self.minimum_validators_per_shard = minimum_validators_per_shard
        self.num_block_producer_seats = num_block_producer_seats
        self.num_block_producer_seats_per_shard = num_block_producer_seats_per_shard
        self.num_blocks_per_year = num_blocks_per_year
        self.num_chunk_only_producer_seats = num_chunk_only_producer_seats
        self.num_chunk_producer_seats = num_chunk_producer_seats
        self.num_chunk_validator_seats = num_chunk_validator_seats
        self.online_max_threshold = online_max_threshold
        self.online_min_threshold = online_min_threshold
        self.protocol_reward_rate = protocol_reward_rate
        self.protocol_treasury_account = protocol_treasury_account
        self.protocol_upgrade_stake_threshold = protocol_upgrade_stake_threshold
        self.protocol_version = protocol_version
        self.shard_layout = shard_layout
        self.shuffle_shard_assignment_for_chunk_producers = shuffle_shard_assignment_for_chunk_producers
        self.target_validator_mandates_per_shard = target_validator_mandates_per_shard
        self.total_supply = total_supply
        self.transaction_validity_period = transaction_validity_period
        self.use_production_config = use_production_config
        self.validators = validators
    }
}

public enum StateChangeWithCauseView: Codable, Sendable {
    case case0(change: String, type: String)
    case case01(change: String, type: String)
    case case02(change: String, type: String)
    case case03(change: String, type: String)
    case case04(change: String, type: String)
    case case05(change: String, type: String)
    case case06(change: String, type: String)
    case case07(change: String, type: String)
    case case08(change: String, type: String)
    case case09(change: String, type: String)
    case case010(change: String, type: String)
}

public enum JsonRpcResponse_for_RpcChunkResponse_and_RpcError: Codable, Sendable {
    case case0(result: RpcChunkResponse)
    case case01(error: RpcError)
}

/// View that preserves JSON format of the runtime config.
public struct RuntimeConfigView: Codable, Sendable {
    /// Config that defines rules for account creation.
    public let account_creation_config: AccountCreationConfigView
    /// The configuration for congestion control.
    public let congestion_control_config: CongestionControlConfigView
    /// Amount of yN per byte required to have on the account.  See
    /// <https://nomicon.io/Economics/Economic#state-stake> for details.
    public let storage_amount_per_byte: NearToken
    /// Costs of different actions that need to be performed when sending and
    /// processing transaction and receipts.
    public let transaction_costs: RuntimeFeesConfigView
    /// Config of wasm operations.
    public let wasm_config: VMConfigView
    /// Configuration specific to ChunkStateWitness.
    public let witness_config: WitnessConfigView

    public init(account_creation_config: AccountCreationConfigView, congestion_control_config: CongestionControlConfigView, storage_amount_per_byte: NearToken, transaction_costs: RuntimeFeesConfigView, wasm_config: VMConfigView, witness_config: WitnessConfigView) {
        self.account_creation_config = account_creation_config
        self.congestion_control_config = congestion_control_config
        self.storage_amount_per_byte = storage_amount_per_byte
        self.transaction_costs = transaction_costs
        self.wasm_config = wasm_config
        self.witness_config = witness_config
    }
}

public struct RpcReceiptRequest: Codable, Sendable {
    public let receipt_id: CryptoHash

    public init(receipt_id: CryptoHash) {
        self.receipt_id = receipt_id
    }
}

/// This type is used to mark function arguments.
/// 
/// NOTE: The main reason for this to exist (except the type-safety) is that the value is
/// transparently serialized and deserialized as a base64-encoded string when serde is used
/// (serde_json).
public typealias FunctionArgs = String

public enum RpcQueryRequest: Codable, Sendable {
    case case0
    case case1
    case case2
    case case3
    case case4
    case case5
    case case6
    case case7
    case case8
    case case9
    case case10
    case case11
    case case12
    case case13
    case case14
    case case15
    case case16
    case case17
    case case18
    case case19
    case case20
    case case21
    case case22
    case case23
}

public typealias Signature = String

/// Describes the error for validating a list of actions.
public enum ActionsValidationError: Codable, Sendable {
    case deleteactionmustbefinal
    case case0(TotalPrepaidGasExceeded: String)
    case case01(TotalNumberOfActionsExceeded: String)
    case case02(AddKeyMethodNamesNumberOfBytesExceeded: String)
    case case03(AddKeyMethodNameLengthExceeded: String)
    case integeroverflow
    case case04(InvalidAccountId: String)
    case case05(ContractSizeExceeded: String)
    case case06(FunctionCallMethodNameLengthExceeded: String)
    case case07(FunctionCallArgumentsLengthExceeded: String)
    case case08(UnsuitableStakingKey: String)
    case functioncallzeroattachedgas
    case delegateactionmustbeonlyone
    case case09(UnsupportedProtocolFeature: String)
    case case010(InvalidDeterministicStateInitReceiver: String)
    case case011(DeterministicStateInitKeyLengthExceeded: String)
    case case012(DeterministicStateInitValueLengthExceeded: String)
}

public enum JsonRpcResponse_for_Array_of_ValidatorStakeView_and_RpcError: Codable, Sendable {
    case case0(result: [ValidatorStakeView])
    case case01(error: RpcError)
}

