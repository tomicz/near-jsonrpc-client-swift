import Foundation

// Get open api near spec
let url = URL(string: "https://raw.githubusercontent.com/near/nearcore/master/chain/jsonrpc/openapi/openapi.json")!
print("Getting near open api spec file location url \(url)")

// Get destination url path
let currentDir = FileManager.default.currentDirectoryPath
let destination = URL(fileURLWithPath: currentDir).appendingPathComponent("open-api-near-spec.json")

print("Open api download destination \(destination.path)")

// Start download from a url
let task = URLSession.shared.downloadTask(with: url) {tempURL, response, error in
    if let error = error{
        print("Download failed! \(error)")         
        exit(1)
    }
    
    guard let tempURL = tempURL else{
        print("No url recieved")
        exit(1)
    }

    do{
        if FileManager.default.fileExists(atPath: destination.path){
            try FileManager.default.removeItem(at: destination)
        }
        try FileManager.default.moveItem(at: tempURL, to: destination)
        print("File saved to destination \(destination.path)") 
        validateOpenApiSpec(at: destination)
    }
    catch{
        print("File error \(error)")
        exit(1)
    }

    exit(0)
 }

 task.resume()
 RunLoop.main.run()

func validateOpenApiSpec(at url: URL){
    do{
        let data = try Data(contentsOf: url)
        let json = try JSONSerialization.jsonObject(with: data, options: [])

        // check open api version
        guard let json = json as? [String: Any],
              let openapi = json["openapi"] as? String,
              openapi == "3.0.0" else{

            print("Invalid open api version")
            exit(1)
        }
        
        print("Open api version is \(openapi)")

        if let info = json["info"] as? [String: Any]{
            for (key, value) in info {
                print("\(key): \(value)")
            }
        }
        generateSwiftTypes(from: json)
    }
    catch{
        print("Error validating open api spec \(error)")
        exit(1)
    }
}

func generateSwiftTypes(from json: [String: Any]) {
    guard let components = json["components"] as? [String: Any],
          let schemas = components["schemas"] as? [String: Any] else {
        print("No schemas found")
        return
    }
    
    print("Found \(schemas.count) schemas, generating Swift types...")
    
    var generatedCode = generateFileHeader()
    
    // Generate types for each schema
    for (schemaName, schemaDefinition) in schemas {
        if let schema = schemaDefinition as? [String: Any] {
            let swiftType = generateSwiftType(name: schemaName, schema: schema)
            generatedCode += swiftType
        }
    }
    
    // Save to output file
    let outputPath = "../../packages/NearJsonRpcTypes/Types.swift"
    let outputURL = URL(fileURLWithPath: outputPath)
    
    // Create directory if it doesn't exist
    let outputDir = outputURL.deletingLastPathComponent()
    try? FileManager.default.createDirectory(at: outputDir, withIntermediateDirectories: true)
    
    do {
        try generatedCode.write(to: outputURL, atomically: true, encoding: .utf8)
        print("✅ Generated \(schemas.count) Swift types at: \(outputPath)")
    } catch {
        print("❌ Error writing file: \(error)")
    }
}

func generateFileHeader() -> String {
    return """
    // Generated by NEAR Protocol Swift Type Generator
    // Do not edit manually - Generated from OpenAPI specification
    // Generated on: \(Date())
    
    import Foundation
    
    """
}

func generateSwiftType(name: String, schema: [String: Any]) -> String {
    let description = schema["description"] as? String
    
    // Check if it's a primitive type (should be a type alias, not a struct)
    if isPrimitiveType(schema: schema) {
        return generateTypeAlias(name: name, description: description, schema: schema)
    }
    
    // Check if it's a union type (oneOf)
    if let oneOf = schema["oneOf"] as? [[String: Any]] {
        return generateEnum(name: name, description: description, oneOf: oneOf)
    }
    
    // Check if it's an empty schema (no properties)
    if isEmptySchema(schema: schema) {
        return generateEmptyStruct(name: name, description: description)
    }
    
    return generateStruct(name: name, description: description, schema: schema)
}

func generateStruct(name: String, description: String?, schema: [String: Any]) -> String {
    var code = ""
    
    // Add documentation
    if let description = description {
        code += "/// \(description.replacingOccurrences(of: "\n", with: "\n/// "))\n"
    }
    
    code += "public struct \(name): Codable {\n"
    
    // Add properties
    if let properties = schema["properties"] as? [String: Any] {
        let required = schema["required"] as? [String] ?? []
        
        for (propName, propDef) in properties {
            if let prop = propDef as? [String: Any] {
                let propDescription = prop["description"] as? String
                let swiftType = mapOpenAPITypeToSwift(prop)
                let isOptional = !required.contains(propName)
                let optionalMark = isOptional ? "?" : ""
                
                if let propDescription = propDescription {
                    code += "    /// \(propDescription.replacingOccurrences(of: "\n", with: "\n    /// "))\n"
                }
                
                code += "    public let \(propName): \(swiftType)\(optionalMark)\n"
            }
        }
    }
    
    // Add initializer
    code += generateInitializer(name: name, schema: schema)
    
    code += "}\n\n"
    return code
}

func generateEnum(name: String, description: String?, oneOf: [[String: Any]]) -> String {
    var code = ""
    
    if let description = description {
        code += "/// \(description.replacingOccurrences(of: "\n", with: "\n/// "))\n"
    }
    
    code += "public enum \(name): Codable {\n"
    
    var caseNames = Set<String>()
    var caseIndex = 0
    
    // Generate cases
    for (index, caseDef) in oneOf.enumerated() {
        if let properties = caseDef["properties"] as? [String: Any] {
            for (caseName, caseDef) in properties {
                let swiftType = mapOpenAPITypeToSwift(caseDef as? [String: Any] ?? [:])
                let finalCaseName = generateUniqueCaseName(caseName.lowercased(), existingNames: &caseNames)
                code += "    case \(finalCaseName)(\(swiftType))\n"
            }
        } else if let enumValues = caseDef["enum"] as? [String] {
            for enumValue in enumValues {
                let finalCaseName = generateUniqueCaseName(enumValue.lowercased(), existingNames: &caseNames)
                code += "    case \(finalCaseName)\n"
            }
        } else {
            // Handle cases without properties or enum values
            let finalCaseName = generateUniqueCaseName("case\(caseIndex)", existingNames: &caseNames)
            code += "    case \(finalCaseName)\n"
            caseIndex += 1
        }
    }
    
    // Add basic Codable implementation
    code += "}\n\n"
    return code
}

func generateUniqueCaseName(_ baseName: String, existingNames: inout Set<String>) -> String {
    var finalName = baseName
    var counter = 1
    
    while existingNames.contains(finalName) {
        finalName = "\(baseName)\(counter)"
        counter += 1
    }
    
    existingNames.insert(finalName)
    return finalName
}

func generateInitializer(name: String, schema: [String: Any]) -> String {
    guard let properties = schema["properties"] as? [String: Any],
          let required = schema["required"] as? [String] else {
        return ""
    }
    
    var code = "\n    public init("
    var parameters: [String] = []
    
    for (propName, propDef) in properties {
        let isOptional = !required.contains(propName)
        let optionalMark = isOptional ? "?" : ""
        let swiftType = mapOpenAPITypeToSwift(propDef as? [String: Any] ?? [:])
        // Use parameter name with type annotation
        parameters.append("\(propName): \(swiftType)\(optionalMark)")
    }
    
    code += parameters.joined(separator: ", ")
    code += ") {\n"
    
    for (propName, _) in properties {
        code += "        self.\(propName) = \(propName)\n"
    }
    
    code += "    }\n"
    return code
}

func mapOpenAPITypeToSwift(_ prop: [String: Any]) -> String {
    // Handle references
    if let ref = prop["$ref"] as? String {
        return extractTypeName(from: ref)
    }
    
    let type = prop["type"] as? String
    let format = prop["format"] as? String
    
    switch (type, format) {
    case ("integer", "uint64"):
        return "UInt64"
    case ("integer", "int32"):
        return "Int32"
    case ("integer", nil):
        return "Int"
    case ("string", nil):
        return "String"
    case ("boolean", nil):
        return "Bool"
    case ("array", _):
        if let items = prop["items"] as? [String: Any] {
            let elementType = mapOpenAPITypeToSwift(items)
            return "[\(elementType)]"
        }
        return "[String]" // Use String instead of Any for arrays
    case ("object", _):
        return "String" // Use String instead of Any for objects
    default:
        return "String" // Use String instead of Any for unknown types
    }
}

func extractTypeName(from ref: String) -> String {
    return ref.components(separatedBy: "/").last ?? "Unknown"
}

func isPrimitiveType(schema: [String: Any]) -> Bool {
    // Check if it's a simple type without properties
    if let type = schema["type"] as? String {
        let hasProperties = schema["properties"] != nil
        let hasOneOf = schema["oneOf"] != nil
        let hasAnyOf = schema["anyOf"] != nil
        
        // If it's a primitive type and has no complex structure, it should be a type alias
        return !hasProperties && !hasOneOf && !hasAnyOf
    }
    return false
}

func isEmptySchema(schema: [String: Any]) -> Bool {
    // Check if schema has no properties or only empty anyOf/oneOf
    if let properties = schema["properties"] as? [String: Any], !properties.isEmpty {
        return false
    }
    
    if let anyOf = schema["anyOf"] as? [[String: Any]] {
        // Check if anyOf has any meaningful content
        for option in anyOf {
            if let optionProperties = option["properties"] as? [String: Any], !optionProperties.isEmpty {
                return false
            }
        }
        return true
    }
    
    if let oneOf = schema["oneOf"] as? [[String: Any]] {
        // Check if oneOf has any meaningful content
        for option in oneOf {
            if let optionProperties = option["properties"] as? [String: Any], !optionProperties.isEmpty {
                return false
            }
        }
        return true
    }
    
    return schema["properties"] == nil
}

func generateTypeAlias(name: String, description: String?, schema: [String: Any]) -> String {
    var code = ""
    
    if let description = description {
        code += "/// \(description.replacingOccurrences(of: "\n", with: "\n/// "))\n"
    }
    
    let swiftType = mapOpenAPITypeToSwift(schema)
    code += "public typealias \(name) = \(swiftType)\n\n"
    
    return code
}

func generateEmptyStruct(name: String, description: String?) -> String {
    var code = ""
    
    if let description = description {
        code += "/// \(description.replacingOccurrences(of: "\n", with: "\n/// "))\n"
    }
    
    code += "public struct \(name): Codable {\n"
    code += "    public init() {}\n"
    code += "}\n\n"
    
    return code
}